\documentclass{scrartcl}

\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{bm}
\usepackage[margin=1in]{geometry}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{tikz}
\usepackage{tikz-cd}
\usepackage{todonotes}
\usepackage{bussproofs}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{listings}
\lstset{
  backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}; should come as last argument
%  basicstyle=\footnotesize,        % the size of the fonts that are used for the code
%  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
%  breaklines=true,                 % sets automatic line breaking
%  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\itshape\rmfamily\color{gray},    % comment style
%  deletekeywords={...},            % if you want to delete keywords from the given language
%  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
%  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
%  firstnumber=1000,                % start line enumeration with line 1000
%  frame=single,	                   % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  columns=flexible,
  keywordstyle=\itshape\bfseries,       % keyword style
  identifierstyle=\rmfamily\itshape,
  language=haskell,                 % the language of the code
  basicstyle=\sffamily\upshape,
  morekeywords=[2]{with,handle,handler,fun},            % if you want to add more keywords to the set
  keywordstyle=[2]\bfseries,       % keyword style
%  morekeywords=[3]{Prob,uniform,bernoulli,normal,beta,exponential},            % if you want to add more keywords to the set
%  keywordstyle=[3]\color{mygreen},       % keyword style
%  numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
 % numbersep=5pt,                   % how far the line-numbers are from the code
%  numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
 % rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
%  stepnumber=2,                    % the step between two line-numbers. If it's 1, each line will be numbered
  stringstyle=\color{mymauve},     % string literal style
 % tabsize=2,	                   % sets default tabsize to 2 spaces
 % title=\lstname                   % show the filename of files included with \lstinputlisting; also try caption instead of title
 escapeinside={(*@}{@*)},
 literate={->}{$\rightarrow\;$}{2}
 {<-}{$\leftarrow\;$}{2}
 {a1}{$a_1$}{2}
 {a2}{$a_2$}{2}
 {vecc}{$\vec{c}$}{1}
 {vecq}{$\vec{q}$}{1}
 {vecd1}{$\vec{d}_1$}{2}
 {vecdl}{$\vec{d}_l$}{2}
 {veca}{$\vec{a}$}{1}
 {vecb1}{$\vec{b}_1$}{1}
 {vecbl}{$\vec{b}_l$}{1}
 {vecbi}{$\vec{b}_i$}{1}
 {y1}{$y_1$}{1}
 {y_l}{$y_l$}{1}
 {c1}{$c_1$}{1}
 {cl}{$c_l$}{1}
 {cr}{$c_r$}{1}
 {k1}{$k_1$}{1}
 {kl}{$k_l$}{1}
 {t1}{$t_1$}{1}
 {tn}{$t_n$}{1}
 {b_1}{$b_1$}{1}
 {u_1}{$u_1$}{1}
 {b_m}{$b_m$}{1}
 {b_i}{$b_i$}{1}
 {y_i}{$y_i$}{1}
 {u_m}{$u_m$}{1}
 {cop}{$c_{\op}$}{2}
 {c_r}{$c_r$}{2}
 {leadsto}{$\leadsto$}{2}
 {mapsto}{$\mapsto$}{2}
 {lambda}{$\lambda$}{1}
 {...}{$\dots$}{1}
 {==}{$\equiv$}{1}
 {_a}{$_a$}{1}
 {c_1}{$c_1$}{1}
 {c_2}{$c_2$}{1}
 {op}{$\op$}{1}
 {c_op}{$c_\op$}{1}
 {c_i}{$c_i$}{1}
 {nu}{$\nu$}{1}
 {psi_n}{$\psi_n$}{1}
 {psi_i}{$\psi_i$}{1}
}

\newcommand{\mlstinline}[1]{\mbox{\lstinline|#1|}}

\usepackage[
    url=false,
    isbn=false,
    maxnames=3,
    maxbibnames=99,
    giveninits
]{biblatex}
\AtEveryBibitem{\clearlist{language}}
\addbibresource{library.bib}

\newtheorem{theorem}{Theorem}
\newtheorem{proposition}[theorem]{Proposition}
\theoremstyle{definition}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{example}[theorem]{Example}

\title{Handlers of Parameterised Algebraic Effects}
\subject{}
\author{Jack Liell-Cock, University of Oxford}
\date{}

\newcommand\cat[1]{\text{\textbf{#1}}}
\newcommand\pbr[1]{\langle #1 \rangle}
\newcommand\bind{\gg\!\!=}
\newcommand{\Set}{\mathbf{Set}}
\newcommand{\Fin}{\mathbf{FinSet}}
\newcommand{\op}{\mathtt{op}}
\newcommand{\Unit}{\mathtt{Unit}}
\newcommand{\Bool}{\mathtt{Bool}}
\newcommand{\sub}{\mathtt{sub}}
\newcommand{\var}{\mathtt{var}}
\newcommand{\PCtx}{\Psi}
\newcommand{\cC}{\underline{C}}
\newcommand{\cD}{\underline{D}}

\begin{document}

\maketitle

\section{Parameterised Algebraic Theories}

We first consider a classic algebraic theory $S$ of parameters. For a signature of operators $\sigma$ with arity function $ar : \sigma \to \mathbb{N}$, the terms in context $\Delta$ are inductively generated by the following:
\begin{prooftree}
    \AxiomC{}
    \UnaryInfC{$\Delta,a\vdash a$}
\end{prooftree}
\begin{prooftree}
    \AxiomC{$\Delta \vdash a_1 \quad\cdots\quad \Delta\vdash a_{ar(f)}$}
    \UnaryInfC{$\Delta \vdash f(a_1,\dots,a_{ar(f)})$}
\end{prooftree}
for $f\in\sigma$.

A signature $T$ parameterised by $S$ is a set of operators $\Sigma$ with arity a natural number and list of natural numbers, $AR: \Sigma \to \mathbb{N} \times \mathbb{N}^*$. For instance, given $F\in\Sigma$,
\[AR(F) = (n\mid m_1,\dots,m_l).\]
We usually denote this as $F : (n\mid m_1,\dots,m_l)$. Intuitively, $n$ is the number of parameters used by $F$ and each $m_i$ is the number of parameters bound in each of the $p$ continuations.

A parametrised context $\Gamma\mid\Delta$ is a finite set of computation variables $\Gamma = x_i:p_1,\cdots,x_n:p_n$ where each variable $x_i$ binds $p_i$ parameters, and a finite set of parameter variables $\Delta = a_1,\cdots,a_m$. Parameterised terms in context $\Gamma\mid\Delta$ are inductively generated by the following:
\begin{prooftree}
    \AxiomC{$\Delta\vdash a_1 \quad \cdots \quad \Delta\vdash a_n$}
    \UnaryInfC{$\Gamma,x:n \mid \Delta \vdash x(a_1,\dots,a_n)$}
\end{prooftree}
\begin{prooftree}
    \AxiomC{$\Delta\vdash \vec{a}$}
    \AxiomC{$\Gamma\mid\Delta,\vec{b}_1\vdash t_1 \quad \cdots \quad \Gamma\mid\Delta,\vec{b}_l\vdash t_l$}
    \BinaryInfC{$\Gamma\mid\Delta\vdash F(\vec{a}, \vec{b}_1.t_1, \cdots, \vec{b}_l.t_l)$}
\end{prooftree}
where $F:(|\vec{a}| \mid |\vec{b}_1|,\dots,|\vec{b}_l|) \in \Sigma$.

A parametrised equation is two terms in the same context, often denoted $\Delta\mid\Gamma\vdash t = s$.

Substitution can be done at the parameter or variable level
\begin{prooftree}
    \AxiomC{$\Delta\vdash a'$}
    \AxiomC{$\Gamma\mid\Delta,a\vdash u$}
    \BinaryInfC{$\Gamma\mid\Delta\vdash u[a'/a]$}
\end{prooftree}
\begin{prooftree}
    \AxiomC{$\Gamma\mid\Delta,\vec{a}\vdash t$}
    \AxiomC{$\Gamma,x:|\vec{a}|\mid\Delta\vdash u$}
    \BinaryInfC{$\Gamma\mid\Delta\vdash u[\vec{a}.t/x]$}
\end{prooftree}

\subsection{Presheaf Semantics}

We build a finitary enriched monad on the self-enriched category $\hat{S}$. The strongly finitely presentable objects of $\hat{S}$ are $J(\vec{n}) := \coprod_{n\in\vec{n}}S({-},n)$ where $\vec{n}$ is a list of natural numbers. For an enriched monad we require:
\begin{itemize}
    \item For each $\vec{n}$, a $T(\vec{n})\in \hat{S}$. We define $T(\vec{n})(p)$ as the set of terms in context $(p\mid\vec{n})$ modulo the equations. The parameter substitution structure gives the functorial action.
    \item For each $\vec{n}$, a morphism $\eta_{\vec{n}} : I\to\hat{S}(J(\vec{n}), T(\vec{n}))$. This picks out the variables as $\hat{S}(J(\vec{n}), T(\vec{n})) \cong \prod_{n\in\vec{n}}T(\vec{n})({-}+n)$ via Yoneda.
    \item For each $\vec{n},\vec{m}$, a morphism $*_{\vec{n},\vec{m}}:\hat{S}(J(\vec{n}), T(\vec{m}))\to \hat{S}(T(\vec{n}), T(\vec{m}))$. The parameterised variable substitution structure provides this. 
\end{itemize}
These data must satisfy the monad coherence laws given by substitution lemmas. So an $S$ parameterised algebraic theory is a finitary enriched monad on $\hat{S}$, or equivalently an $\hat{S}$-enriched Lawvere theory. When the parametrising theory is the theory of sets, $\hat{S}$ reduces to the functor category $[\Fin,\Set]$.

\subsection{Example: Local Store}

\newcommand{\get}{\mathsf{get}}
\newcommand{\set}[1]{\mathsf{set}_{#1}}
\newcommand{\eq}{\mathsf{eq}}
\newcommand{\rf}{\mathsf{ref}}

The theory of local store~\cite{staton_instances_2013} is an algebraic theory parameterised by the theory of sets. In this case, the parameters represent the different memory cells. There are four operators.
\begin{itemize}
    \item $\get : (1\mid 0, 0)$ reads the bit of memory in the parameter and continues with the first continuation if it is false and the second if it is true
    \item $\set{i} : (1 \mid 0)$ writes $i$ to the bit of memory in the parameter
    \item $\ref_i : (0 \mid 1)$ creates a new memory cell bound to the parameter in the continuation initialised to $i$
    \item $\eq : (2\mid 0, 0)$ checks if two parameters are equal and continues with the first continuation if they are and the second if they are not
\end{itemize}

A sample of the set of equations for the theory are:
\begin{align*}
    x: 0 \mid a, b &\vdash \set i(a,\set j(b, x)) = \eq(a,b, \set j(a, x), \set j(b, \set i(a,x))) \\
    x_0:0,x_1:0\mid a,b &\vdash \set i(a, \get(b, x_0,x_1)) \\
    &\qquad = \eq(a,b, \set i(a, x_i), \get(b , \set i(a, x_0), \set i(a, x_1))) \\
    x:0 \mid a &\vdash x = \get(a, \set 0(a, x), \set 1(a, x)) \\
    x:0 \mid a,b &\vdash x = \eq(a,b, x,x) \\
    u:0,v:0,x:0,y:0\mid a,b,c,d &\vdash \eq(a,b , \eq(c,d , u,v), \eq(c,d , x,y)) \\
    &\qquad = \eq(c,d, \eq(a,b, u,x), \eq(a,b, v,y)) \\
    x:1,y:0 \mid a,b &\vdash \eq(a,b, x[a],y) = \eq(a,b, x[b],y) \\
    x: 0 \mid - &\vdash \rf(a.x) = x \\
    x: 2 \mid - &\vdash \rf(a.\rf(b.x[a,b])) = \rf(b.\rf(a.x[a,b]))
\end{align*}

\subsection{Example: Substitution and Jumps}

An example that doesn't trivially collapse the list of arity types to a singleton for each operator is the theory of substitution~\cite{fiore_substitution_2014}. In this case, the parameters represent code labels. There are two operators
\begin{itemize}
    \item $\sub : (0\mid 1, 0)$ attaches a label to the current code point and continues with the first continuation
    \item $\var : (1 \mid -)$ jumps back to the associated code point and continues with the latter continuation
\end{itemize}
The full set of equational laws for the theory are:
\begin{align*}
    x: 0 \mid - &\vdash \sub(a.\var(a), x) = x \\
    x: 0, y:0 \mid - &\vdash \sub(a.x,y) = x \\
    x: 1 \mid a &\vdash \sub(b.x[b], \var(a)) = x[a] \\
    x:2, y:1, z:0 \mid - &\vdash
    \sub(a.\sub(b.x[a, b], y[a]), z) = \sub(b.\sub(a.x[a, b], z), \sub(a.y[a], z))
\end{align*}

\subsection{Further Examples}

A range of other effects captured by parameterised algebraic theories are:
\begin{itemize}
    \item Restriction \cite{staton_instances_2013} in the sense of \cite{pitts_structural_2011}
    \item $\pi$-calculus \cite{staton_instances_2013}
    \item Quantum information \cite{staton_algebraic_2015}
    \item Scoped effects~\cite{lindley_scoped_2024}
\end{itemize}

\section{Parameterised Effect Handlers}

The goal of handlers of parameterised algebraic theories is to extend the regular algebraic effect framework to incorporate parameterised algebraic effects.
Currently, these have \emph{not} been defined or implemented in literature.

\subsection{Delimited Continuations}

In the delimited continuation implementation of classical algebraic effects, we start with an operator of type signature
\[
    \op: A \leadsto B
\]
that signifies that an operation is called with an argument of type $A$, and in the continuation of the operation it receives a value of type $B$.
These are the \emph{coarity} and \emph{arity} types, respectively.

\begin{example}
For local binary state, the type signatures would become:
\begin{align*}
    \get &: \alpha \leadsto \Bool \\
    \set{} &: \alpha \times \Bool \leadsto 1 \\
    \rf  &: \Bool \leadsto \alpha \\
    \eq  &: \alpha \times \alpha \leadsto \Bool
\end{align*}
\end{example}

Note, that the coarity type captures the \emph{configuation} of the operator (i.e. the $i$ in $\set i$ or $\rf_i$).
In contrast, the arity type can group continuations with the same parameter bind count (i.e. instead of two continuations in $r$ we have a single continuation with argument $\Bool$).

\begin{example}
For substitution, the type signatures would become:
\begin{align*}
    \sub &: 1 \leadsto \alpha + 1 \\
    \var &: \alpha \leadsto 0
\end{align*}
\end{example}

\subsection{Handlers}

Motivated by the presheaf semantics of the parametrised algebraic theories, we can think of the return type of a handler as a type that is dependant on a \emph{context} of parameters (i.e. a map from context to set). We first start with some examples to get a feel for how this should work.

\subsubsection{Example: Substitution}

For the theory of substitution, the handler will either return a value $R$ or a parameter in provable by the current parameter context.
We use $\PCtx$ to represent the latter. Hence we expect the return type to look like $R+\PCtx$.
\begin{lstlisting}
    handler {
      return x  -> return (inl x)
      var(v; k) -> return (inr v)
      sub(v; k) -> do a <- #new () in
        case k (inl a) of {
          inl x -> return (inl x),
          inr b -> if b == a then k (inr ()) else return (inr b)
        }
    }
\end{lstlisting}

\subsubsection{Example: Local Binary State}

We may follow a similar path to create a handler for local binary state.
In this theory, the parameters represent reference cells, so we can represent our local memory by the function type $\PCtx \to S$, where $\PCtx$
is our context of parameters and $S$ is the type of values in memory. So the whole return type of the handler in parameter passing style would be
$(\PCtx \to S) \to R \times (\PCtx \to S)$. The implementation of the handler from here is straightforward apart from the implementation of the operator
$\rf$ in which the continuation produces a return type with the parameter context extended by a fresh parameter, or $(\PCtx +1 \to S) \to R \times (\PCtx + 1 \to S)$.
We can see how it is handled below.
\begin{lstlisting}
    handler {
        return x  -> return (fun s -> return (x,s))
        get(v; k) -> return (fun s -> k (s v) s)
        set(v; k) -> return (fun s -> k () (fun a -> if a == fst v then snd v else s a)
        ref(v; k) -> do a <- #new () in
            return (fun s -> k a (fun b -> if a == b then return v else return s b))
    }
\end{lstlisting}

\section{Type System}

The type and effect system closely follows that of~\cite{pretnar_introduction_2015}. We have an extra parameter type that captures the current parameter context. 
\begin{align*}
    A, B &::= \PCtx \mid \Unit \mid A + B \mid A \times B \mid A \to \cC \mid \cC \Rightarrow \cD \\
    \cC, \cD &::= A!\Sigma \\
    \Sigma &::= \{\op_1,\dots,\op_n\}
\end{align*}
where $n\in\mathbb{N}$ represents the number of times we extend the parameter context within the typed term.

\section{Reasoning with Equations}

We may prove the equations hold in our handlers using equational reasoning. We begin with examples from the theory of substitution...

\printbibliography

\end{document}
