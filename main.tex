\documentclass{scrartcl}

\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{bm}
\usepackage[margin=1in]{geometry}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{tikz}
\usepackage{tikz-cd}
\usepackage{todonotes}
\usepackage{bussproofs}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{listings}
\lstset{
  backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}; should come as last argument
%  basicstyle=\footnotesize,        % the size of the fonts that are used for the code
%  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
%  breaklines=true,                 % sets automatic line breaking
%  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\itshape\rmfamily\color{gray},    % comment style
%  deletekeywords={...},            % if you want to delete keywords from the given language
%  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
%  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
%  firstnumber=1000,                % start line enumeration with line 1000
%  frame=single,	                   % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  columns=flexible,
  keywordstyle=\itshape\bfseries,       % keyword style
  identifierstyle=\rmfamily\itshape,
  language=haskell,                 % the language of the code
  basicstyle=\sffamily\upshape,
  morekeywords=[2]{with,handle,handler,where},            % if you want to add more keywords to the set
  keywordstyle=[2]\itshape\bfseries,       % keyword style
%  morekeywords=[3]{Prob,uniform,bernoulli,normal,beta,exponential},            % if you want to add more keywords to the set
%  keywordstyle=[3]\color{mygreen},       % keyword style
%  numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
 % numbersep=5pt,                   % how far the line-numbers are from the code
%  numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
 % rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
%  stepnumber=2,                    % the step between two line-numbers. If it's 1, each line will be numbered
  stringstyle=\color{mymauve},     % string literal style
 % tabsize=2,	                   % sets default tabsize to 2 spaces
 % title=\lstname                   % show the filename of files included with \lstinputlisting; also try caption instead of title
 escapeinside={(*@}{@*)},
 literate={->}{$\rightarrow\;$}{2}
 {<-}{$\leftarrow\;$}{2}
 {a1}{$a_1$}{2}
 {a2}{$a_2$}{2}
 {vecc}{$\vec{c}$}{1}
 {vecd1}{$\vec{d}_1$}{2}
 {vecdp}{$\vec{d}_p$}{2}
 {veca}{$\vec{a}$}{1}
 {vecb1}{$\vec{b}_1$}{1}
 {vecbp}{$\vec{b}_p$}{1}
 {y1}{$y_1$}{1}
 {yp}{$y_p$}{1}
 {c1}{$c_1$}{1}
 {cp}{$c_p$}{1}
 {cr}{$c_r$}{1}
 {k1}{$k_1$}{1}
 {kp}{$k_p$}{1}
 {t1}{$t_1$}{1}
 {tn}{$t_n$}{1}
 {cop}{$c_{op}$}{2}
 {leadsto}{$\leadsto$}{2}
 {mapsto}{$\mapsto$}{2}
 {lambda}{$\lambda$}{1}
 {...}{$\dots$}{1}
 {==}{$\equiv$}{1}
}

\newcommand{\mlstinline}[1]{\mbox{\lstinline|#1|}}

\usepackage[
    url=false,
    isbn=false,
    maxnames=3,
    maxbibnames=99,
    giveninits
]{biblatex}
\AtEveryBibitem{\clearlist{language}}
\addbibresource{library.bib}

\newtheorem{theorem}{Theorem}
\newtheorem{proposition}[theorem]{Proposition}
\theoremstyle{definition}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{example}[theorem]{Example}

\title{Handlers of Parameterised Algebraic Effects}
\subject{}
\author{Jack Liell-Cock, University of Oxford}
\date{}

\newcommand\cat[1]{\text{\textbf{#1}}}
\newcommand\bind{\gg\!\!=}
\newcommand{\Set}{\mathbf{Set}}
\newcommand{\Fin}{\mathbf{FinSet}}
\newcommand{\op}{\mathtt{op}}
\newcommand{\Unit}{\mathtt{Unit}}
\newcommand{\Bool}{\mathtt{Bool}}
\newcommand{\sub}{\mathtt{sub}}
\newcommand{\var}{\mathtt{var}}

\begin{document}

\maketitle

\section{Parameterised Algebraic Theories}

We first consider a classic algebraic theory $S$ of parameters. For a signature of operators $\sigma$ with arity function $ar : \sigma \to \mathbb{N}$, the terms in context $\Delta$ are inductively generated by the following:
\begin{prooftree}
    \AxiomC{$a\in\Delta$}
    \UnaryInfC{$\Delta\vdash a$}
\end{prooftree}
\begin{prooftree}
    \AxiomC{$\Delta \vdash a_1 \cdots \Delta\vdash a_{ar(f)}$}
    \UnaryInfC{$\Delta \vdash f(a_1,\dots,a_{ar(f)})$}
\end{prooftree}
for $f\in\sigma$. Often, the parameter signature is considered to be empty so we have the theory of sets.

A signature $T$ parameterised by $S$ is a set of operators $\Sigma$ with arity a natural number and list of natural numbers, $AR: \Sigma \to \mathbb{N} \times \mathbb{N}^*$. For instance, given $F\in\Sigma$,
\[AR(F) = (n\mid m_1,\dots,m_p).\]
We usually denote this as $F : (m\mid m_1,\dots,m_p)$. Intuitively, $n$ is the number of parameters used by $F$ and each $m_i$ is the number of parameters bound in each of the $p$ continuations.

A parametrised context $\Gamma\mid\Delta$ is a finite set of computation variables $\Gamma = x_i:p_1,\cdots,x_n:p_n$ where each variable $x_i$ binds $p_i$ parameters, and a finite set of parameter variables $\Delta = a_1,\cdots,a_m$. Parameterised terms in context $\Gamma\mid\Delta$ are inductively generated by the following:
\begin{prooftree}
    \AxiomC{$\Delta\vdash \vec{a}$}
    \UnaryInfC{$\Gamma,x:|\vec{a}|\mid \Delta \vdash x(\vec{a})$}
\end{prooftree}
\begin{prooftree}
    \AxiomC{$\Delta\vdash \vec{a}$}
    \AxiomC{$\Gamma\mid\Delta,\vec{b}_1\vdash t_1 \quad \cdots \quad \Gamma\mid\Delta,\vec{b}_p\vdash t_p$}
    \BinaryInfC{$\Gamma\mid\Delta\vdash F(\vec{a}, \vec{b}_1.t_1, \cdots, \vec{b}_p.t_p)$}
\end{prooftree}
where $F:(|\vec{a}| \mid |\vec{b}_1|,\dots,|\vec{b}_p|) \in \Sigma$.

A parametrised equation is two terms in the same context, often denoted $\Delta\mid\Gamma\vdash t = s$.

Substitution can be done at the parameter or variable level
\begin{prooftree}
    \AxiomC{$\Delta\vdash a'$}
    \AxiomC{$\Gamma\mid\Delta,a\vdash u$}
    \BinaryInfC{$\Gamma\mid\Delta\vdash u[a'/a]$}
\end{prooftree}
\begin{prooftree}
    \AxiomC{$\Gamma\mid\Delta,\vec{a}\vdash t$}
    \AxiomC{$\Gamma,x:|\vec{a}|\mid\Delta\vdash u$}
    \BinaryInfC{$\Gamma\mid\Delta\vdash u[\vec{a}.t/x]$}
\end{prooftree}

\subsection{Presheaf Semantics}

We build a finitary enriched monad on the self-enriched category $\hat{S}$. The strongly finitely presentable objects of $\hat{S}$ are $J(\vec{n}) := \coprod_{n\in\vec{n}}S({-},n)$ where $\vec{n}$ is a list of natural numbers. For an enriched monad we require:
\begin{itemize}
    \item For each $\vec{n}$, a $T(\vec{n})\in \hat{S}$. We define $T(\vec{n})(p)$ as the set of terms in context $(p\mid\vec{n})$ modulo the equations. The parameter substitution structure gives the functorial action.
    \item For each $\vec{n}$, a morphism $\eta_{\vec{n}} : I\to\hat{S}(J(\vec{n}), T(\vec{n}))$. This picks out the variables as $\hat{S}(J(\vec{n}), T(\vec{n})) \cong \prod_{n\in\vec{n}}T(\vec{n})({-}+n)$ via Yoneda.
    \item For each $\vec{n},\vec{m}$, a morphism $*_{\vec{n},\vec{m}}:\hat{S}(J(\vec{n}), T(\vec{m}))\to \hat{S}(T(\vec{n}), T(\vec{m}))$. The parameterised variable substitution structure provides this. 
\end{itemize}
These data must satisfy the monad coherence laws given by substitution lemmas. So an $S$ parameterised algebraic theory is a finitary enriched monad on $\hat{S}$, or equivalently an $\hat{S}$-enriched Lawvere theory. When the parametrising theory is the theory of sets, $\hat{S}$ reduces to the functor category $[\Fin,\Set]$.

\subsection{Example: Local Store}

The theory of local store~\cite{staton_instances_2013} is an algebraic theory parameterised by the theory of sets. In this case, the parameters represent the different memory cells. There are four operators.
\begin{itemize}
    \item $r : (1\mid 0, 0)$ reads the bit of memory in the parameter and continues with the first continuation if it is false and the second if it is true
    \item $w_i : (1 \mid 0)$ writes $i$ to the bit of memory in the parameter
    \item $\nu_i : (0 \mid 1)$ creates a new memory cell bound to the parameter in the continuation initialised to $i$
    \item $eq : (2\mid 0, 0)$ checks if two parameters are equal and continues with the first continuation if they are and the second if they are not
\end{itemize}
A sample of the set of equations for the theory are (sorry I got tired writing them all out -- this should give the idea):
\begin{align*}
    x: 0 \mid a, b &\vdash w_i(a,w_j(b, x)) = eq(a,b\mid w_j(a, x), w_j(b, w_i(a,x))) \\
    x_0:0,x_1:0\mid a,b &\vdash w_i(a\mid r(b\mid x_0,x_1)) = eq(a,b\mid w_i(a\mid x_i), r(b \mid w_i(a\mid x_0), w_i(a\mid x_1))) \\
    x:0 \mid a &\vdash x = r(a\mid w_0(a\mid x), w_1(a\mid x)) \\
    x:0 \mid a,b &\vdash x = eq(a,b\mid x,x) \\
    u:0,v:0,x:0,y:0\mid a,b,c,d &\vdash eq(a,b \mid eq(c,d \mid u,v), eq(c,d \mid x,y)) \\
    &\qquad = eq(c,d\mid eq(a,b\mid u,x), eq(a,b\mid v,y)) \\
    x:1,y:0 \mid a,b &\vdash eq(a,b\mid x[a],y) = eq(a,b\mid x[b],y) \\
    x: 0 \mid - &\vdash \nu a.x = x \\
    x: 2 \mid - &\vdash \nu a.\nu b.x[a,b] = \nu b.\nu a.x[a,b]
\end{align*}

\subsection{Example: Substitution and Jumps}

An example that doesn't trivially collapse the list of arity types to a singleton for each operator is the theory of substitution~\cite{fiore_substitution_2014}. In this case, the parameters represent code labels. There are two operators
\begin{itemize}
    \item $\sub : (0\mid 1, 0)$ attaches a label to the current code point and continues with the first continuation
    \item $\var : (1 \mid -)$ jumps back to the associated code point and continues with the latter continuation
\end{itemize}
The full set of equational laws for the theory are:
\begin{align*}
    x: 0 \mid - &\vdash \sub(a.\var(a), x) = x \\
    x: 0, y:0 \mid - &\vdash \sub(a.x,y) = x \\
    x: 1 \mid a &\vdash \sub(b.x[b], \var(a)) = x[a] \\
    x:2, y:1, z:0 \mid - &\vdash
    \sub(a.\sub(b.x[a, b], y[a]), z) = \sub(b.\sub(a.x[a, b], z), \sub(a.y[a], z))
\end{align*}

\subsection{Further Examples}

A range of other effects captured by parameterised algebraic theories are:
\begin{itemize}
    \item Restriction \cite{staton_instances_2013} in the sense of \cite{pitts_structural_2011}
    \item $\pi$-calculus \cite{staton_instances_2013}
    \item Quantum information \cite{staton_algebraic_2015}
    \item Scoped effects~\cite{lindley_scoped_2024}
\end{itemize}

\section{Parameterised Effect Handlers}

The goal of handlers of parameterised algebraic theories is to extend the regular algebraic effect framework to incorporate parameterised algebraic effects. Currently, these have \emph{not} been defined or implemented in literature. I think there are two approaches to this based on the delimited continuation and free monad implementations of algebraic effects.

The first is free monad implementations, such as in~\cite{wu_effect_2014}. I have not thought too deeply about this area yet but I believe the programs could be represented via the free monad of the parameterised algebraic theory and semantics can be given via a fold. However in this case the free monad would be over $\hat{S}$ (or $[\Fin,\Set]$) rather than $\Set$, so the idea does not immediately carry over.

The second is the delimited continuation approach which I explore in greater detail in this section.

\subsection{Delimited Continuations}

In the delimited continuation implementation of classical algebraic effects, we start with an operator of type signature
\[
    \op: A \hookrightarrow B
\]
that signifies that an operation is called with an argument of type $A$, and in the continuation of the operation it receives a value of type $B$. These are the \emph{coarity} and \emph{arity} types, respectively.

This must be generalised to account for parameterised algebraic theories. I propose to generalise in the following way. Firstly, we make the arity type a list of types,
\[
    \op: A \hookrightarrow (B_1,\dots, B_p).
\]

This alone gives no additional expressibility because it can be classically captured as a single sum type,
\[
    \op : A \hookrightarrow B_1 + \dots + B_p,
\]
with case analysis in the continuation. But generalising further we attach a natural number to each type,
\[
    \op : (n, A) \hookrightarrow (m_1,B_1;\dots ; m_p,B_p)
\]
which indicates the number of parameters used and bound in each of the continuations of the operator (i.e. in the parameterised algebraic theory the corresponding operator would have arity $\op : (n \mid m_1, \dots, m_p)$).

\todo[inline]{I think this could be related better to \emph{generic effects}~\cite{plotkin_algebraic_2003}}

\begin{example}
For local binary state, the type signatures would become:
\begin{align*}
    r &: (1, \Unit) \hookrightarrow (0, \Bool) \\
    w &: (1, \Bool) \hookrightarrow (0, \Unit) \\
    \nu &: (0, \Bool) \hookrightarrow (1, \Unit) \\
    eq&: (2, \Unit) \hookrightarrow (0, \Bool)
\end{align*}
\end{example}

Note, that the coarity type captures the \emph{configuation} of the operator (i.e. the $i$ in $w_i$ or $\nu_i$). In contrast, the arity type can group continuations with the same parameter bind count (i.e. instead of two continuations in $r$ we have a single continuation with argument $\Bool$).

\begin{example}
For substitution, the type signatures would become:
\begin{align*}
    \sub &: (0, \Unit) \hookrightarrow (1, \Unit; 0, \Unit) \\
    \var &: (1, \Unit) \hookrightarrow ()
\end{align*}
\end{example}

\subsubsection{Commuting with Let-Expressions}

We expect the operational semantics of the interaction with operation calls and let expressions in classical effect handlers to be the following.
\begin{lstlisting}
  let x = op(v; c) in e leadsto op(v; let x = c in e)
\end{lstlisting}
However in handlers of parameterised algebraic theories there can be multiple or no continuations. Generalising the operational semantics (for, say, the substitution example) would give the following.
\begin{lstlisting}
  let x = sub[]((); [a]c, c') in e leadsto sub[]((); [a]let x = c in e, let x = c' in e)
  let x = var[a]((); -) in e leadsto var[a]((); -)
\end{lstlisting}
This second example looks partivularly suspicious because if \lstinline{x} is not free in \lstinline{e} then we seem to be equating \lstinline{var[a]((); -)} to all expressions and thus the
type system would be unsound. However, this is not the case because control is never given back to the delimited continuation when the \lstinline{var} operator is called. It is similar to the
case with exceptions where one would expect
\begin{lstlisting}
  let x = fail() in e leadsto fail()
\end{lstlisting}
even if \lstinline{x} is not free in \lstinline{e}.

\subsection{Handlers}

Motivated by the presheaf semantics of the parameterised algebraic theories, we can think of the return type of a handler as a type that is dependant on a \emph{context} of parameters (i.e. a map from context to set). We first start with some examples to get a feel for how this should work.

\subsubsection{Example: Substitution}

For the theory of substitution, the handler will either return a value $R$ or a parameter in context $\Delta$. Hence we expect the return type to look like $R+\Delta$. So given the layout
\begin{lstlisting}
    H = handler {
        return x         = ...
        sub[]((); k, k') = ...
        var[a](();)      = ...
    }
\end{lstlisting}
we expect the return operation to simply inject the return value into the return type
\begin{lstlisting}
    return x = inl x
\end{lstlisting}
and the $\var$ operator to inject the parameter (which we assume exists within our context $\Delta$) into the context type.
\begin{lstlisting}
    var[a](();) = inr a
\end{lstlisting}
However, for the $\sub$ operator, the continuation $k$ returns a value in a context extended by an additional parameter, that is a value in $R + (\Delta + 1)$. So in this case if our value comes from the $R$ or $\Delta$ component, we may simply return the result, otherwise, we call $k'$ for a new value in $R+\Delta$. This results in the following code.
\begin{lstlisting}
    sub[]((); k, k') = case k () of
                            inl x        = inl x
                            inr (inl a)  = inr a
                            inr (inr ()) = k' ()
\end{lstlisting}

\subsubsection{Example: Local Binary State}

We may follow a similar path to create a handler for local binary state. In this theory, the parameters represent reference cells, so we can represent our local memory by the function type $\Delta \to S$, where $\Delta$ is our context of parameters and $S$ is the type of values in memory. So the whole return type of the handler in parameter passing style would be $(\Delta \to S) \to R \times (\Delta \to S)$. The implementation of the handler from here is straightforward apart from the implementation of the operator $\nu$ in which the continuation produces a return type with the parameter context extended by a fresh parameter, or $(\Delta +1 \to S) \to R \times (\Delta + 1 \to S)$. We can see how it is handled below.
\begin{lstlisting}
    H = handler {
        return x      = lambdas.(x,s)
        get[a]((); k) = lambdas.k (s a) s
        set[a](v; k)  = lambdas.k () (lambdab.if a == b then x else s b)
        new[](v; k)   = lambdas.let s' (inr ()) = v
                               s' (inl x)  = s x
                               (v', s'') = k () s'
                           in  (v', lambdab.s'' (inl b))
    }
\end{lstlisting}
There are a few elegant aspects of this approach:
\begin{itemize}
    \item It prevents the fresh parameter names from escaping their continuation context. In particular, we cannot simply return \lstinline{(v',s'')} in the handler for the \lstinline{new} operator because it is of type $R\times (\Delta+1\to S)$, while the handler expects a return type of $R\times (\Delta \to S)$. So we are forced to restrict the function from the fresh parameter before returning it. Even though the function could not be called with the fresh parameter because it is an abstract instance no longer in scope, this formally guarantees that.
    \item For closed terms (which are the terms we expect from regular programs), the parameter context would be empty ($\Delta \cong 0$). This nicely restricts how the return type of the handler can be used. For example, in the substitution case, the result would be $R + \Delta = R + 0 \cong R$ giving only a result type. In the local binary state case, the return type would be $(0 \to S) \to R \times (0 \to S) \cong R$ because $0$ is initial.
\end{itemize}
However, we have brushed past an issue with this solution. That is, what do the coarity parameters refer to in the operators. For instance, say we have the following line of code.
\begin{lstlisting}
    sub(... sub(var[a](()), t1), ...), tn)
\end{lstlisting}
What does the \lstinline{a} refer to here? By the inductive construction of $\Delta$, we would expect it to be of the form \lstinline{inl ( ... inl (inr ()) ... )}, but attempting to reference the
right substitution by the number of \lstinline{inl}s in the parameter name in the is not conducive to good coding practices. Hence the goal is to extend the type system to give names to each of the context parameters so that
they can be easily referenced within the program. I am still in the process of finding a good way to format this so I have not typeset it yet.

\subsubsection{Introducing new Parameters}

This raises the question of how to introduce these new parameters $\vec{d}_i$ in the final step. I think Sean Moss is right about never needing to instantiate parameters. The best way is to keep this parameter type existentially abstract so they can only be used in globally quantified type variables (i.e. keys in maps). Maybe have a few type restrictions such as ordering and equality so they can be elements of sets (i.e. for implementation in functional programs). So introducing these references is just a matter of ensuring their identifier is unique.

\section{Type System}

\todo[inline]{Finish/fix this section}

Again we follow from the type system given in \cite{kammar_no_2017}. The new handler typing terms are given by:

\begin{prooftree}
    \AxiomC{$\Delta \mid \Gamma, x:A \vdash c_r : B!\Sigma'$}
    \AxiomC{$\Sigma \subseteq \Sigma'$}
    \BinaryInfC{$\Delta \mid \Gamma \vdash$ \lstinline|handler \{ return x mapsto cr \} | $: A!\Sigma \Rightarrow B!\Sigma'$}
\end{prooftree}

\begin{prooftree}
    \AxiomC{$\Delta \mid \Gamma \vdash H : A!\Sigma \Rightarrow B!\Sigma'$}
    \noLine
    \UnaryInfC{$op : (|\vec{a}|, A') \hookrightarrow [(|\vec{b}_1|, B_1), \dots , (|\vec{b}_p|,B_p)]$}
    \noLine
    \UnaryInfC{$\Delta, \vec{a} \mid \Gamma, x:A', k_1: B_1 \to [\vec{b}_1]B!\Sigma', \dots, k_p:B_p \to [\vec{b}_p]B!\Sigma' \vdash c_{op} : B!\Sigma'$}
    \UnaryInfC{$\Delta \mid \Gamma \vdash (op[\vec{a}](x; [\vec{b}_1]k_1, \dots , [\vec{b}_p]k_p) \mapsto c_{op}); H : A!\Sigma \cup \{op\} \Rightarrow B!\Sigma'$}
\end{prooftree}

\printbibliography

\end{document}
