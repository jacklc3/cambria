\documentclass{article}

\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage[margin=1in]{geometry}
\usepackage{mathpartir}

% ── Macros ──────────────────────────────────────────────────────
\newcommand{\void}{\mathsf{Void}}
\newcommand{\unit}{\mathsf{Unit}}
\newcommand{\tint}{\mathsf{Int}}
\newcommand{\tbool}{\mathsf{Bool}}
\newcommand{\tdouble}{\mathsf{Double}}
\newcommand{\tstring}{\mathsf{Str}}
\newcommand{\tunique}{\mathsf{Unique}}

\newcommand{\tfun}[2]{#1 \to #2}
\newcommand{\tpair}[2]{#1 \times #2}
\newcommand{\teither}[2]{#1 + #2}
\newcommand{\thandler}[2]{#1 \Rightarrow #2}
\newcommand{\thandlerp}[3]{#1 \xRightarrow{#2} #3}

\newcommand{\comp}[2]{#1\;!\;#2}
\newcommand{\arity}[2]{#1 \leadsto #2}

\newcommand{\op}{\mathsf{op}}
\newcommand{\ret}{\mathsf{return}\;}
\newcommand{\ddo}{\mathsf{do}\;}
\newcommand{\iin}{\;\mathsf{in}\;}
\newcommand{\iif}{\mathsf{if}\;}
\newcommand{\then}{\;\mathsf{then}\;}
\newcommand{\eelse}{\;\mathsf{else}\;}
\newcommand{\ccase}{\mathsf{case}\;}
\newcommand{\oof}{\;\mathsf{of}\;}
\newcommand{\inl}{\mathsf{inl}\;}
\newcommand{\inr}{\mathsf{inr}\;}
\newcommand{\fun}{\mathsf{fun}\;}
\newcommand{\rec}{\mathsf{rec}\;}
\newcommand{\hhandler}{\mathsf{handler}}
\newcommand{\with}{\mathsf{with}\;}
\newcommand{\handle}{\;\mathsf{handle}\;}
\newcommand{\declare}{\mathsf{declare}\;}

\newcommand{\G}{\Gamma}
\newcommand{\Sig}{\Sigma}
\newcommand{\ftv}{\mathsf{ftv}}
\newcommand{\ftp}{\mathsf{ftp}}

\newcommand{\vj}[3]{#1 \vdash #2 : #3}                   % value judgement
\newcommand{\cj}[4]{#1 \vdash #2 : \comp{#3}{#4}}        % comp judgement
\newcommand{\cjp}[3]{#1 \vdash #2 : #3}                  % comp judgement (pre-formed)

\title{Typing Rules for Cambria}
\author{}
\date{}

\begin{document}
\maketitle

%% ═══════════════════════════════════════════════════════════════
\section{Types}
%% ═══════════════════════════════════════════════════════════════

\[
\begin{array}{lrcl}
  \text{Value types}       & A, B & ::= & \void \mid \unit \mid \tpair{A}{B} \mid \teither{A}{B} \mid \tfun{A}{C} \mid \thandlerp{C}{\sigma}{D} \\[6pt]
  \text{Computation types} & C, D & ::= & \comp{A}{\Sig} \\[6pt]
  \text{Effect signatures} & \Sig & ::= & \{ \op_1 : A_1 \leadsto B_1,\; \ldots,\; \op_n : A_n \leadsto B_n \} \\[6pt]
  \text{Param.\ subst.}    & \sigma & ::= & \{ \$p_1 \mapsto A_1,\; \ldots,\; \$p_m \mapsto A_m \}
\end{array}
\]

A judgement $\vj{\G}{v}{A}$ types a value $v$ under context $\G$.
A judgement $\cj{\G}{c}{A}{\Sig}$ types a computation $c$ that produces a value of type $A$ and may perform effects in $\Sig$.

Type parameters $\$p$ may appear free in effect signatures.
We write $\sigma(\Sig)$ for the application of a parameter substitution to an effect signature, replacing each $\$p \in \mathrm{dom}(\sigma)$ with $\sigma(\$p)$ in all arities.
We write $\Sig \setminus \{\op_1, \ldots, \op_n\}$ for the restriction of $\Sig$ to operations not in $\{\op_1, \ldots, \op_n\}$.

%% ═══════════════════════════════════════════════════════════════
\section{Value Typing}\label{sec:values}
%% ═══════════════════════════════════════════════════════════════

Rules for judgements of the form $\vj{\G}{v}{A}$.

\begin{mathpar}
  \inferrule
    {(x : A) \in \G}
    {\vj{\G}{x}{A}}
    \quad (\textsc{Var})

  \inferrule
    { }
    {\vj{\G}{()}{\unit}}
    \quad (\textsc{Unit})

  \inferrule
    {b \in \{\mathsf{true}, \mathsf{false}\}}
    {\vj{\G}{b}{\tbool}}
    \quad (\textsc{Bool})

  \inferrule
    {\vj{\G}{v_1}{A} \\ \vj{\G}{v_2}{B}}
    {\vj{\G}{(v_1, v_2)}{\tpair{A}{B}}}
    \quad (\textsc{Pair})

  \inferrule
    {\vj{\G}{v}{A}}
    {\vj{\G}{\inl v}{\teither{A}{B}}}
    \quad (\textsc{Inl})

  \inferrule
    {\vj{\G}{v}{B}}
    {\vj{\G}{\inr v}{\teither{A}{B}}}
    \quad (\textsc{Inr})

  \inferrule
    {\cjp{\G, x : A}{c}{C}}
    {\vj{\G}{\fun x \mapsto c}{\tfun{A}{C}}}
    \quad (\textsc{Fun})

  \inferrule
    {\cj{\G, f : \tfun{A}{\comp{B}{\Sig§}},\, x : A}{c}{B}{\Sig}}
    {\vj{\G}{\rec f\; x \mapsto c}{\tfun{A}{\comp{B}{\Sig}}}}
    \quad (\textsc{Rec})
\end{mathpar}

%% ═══════════════════════════════════════════════════════════════
\section{Handler Typing}\label{sec:handler}
%% ═══════════════════════════════════════════════════════════════

A handler has the form:
\[
  \hhandler\;\{
    \$p_1 \mapsto A_1, \ldots, \$p_m \mapsto A_m,\;
    \ret x_r \mapsto c_r,\;
    \op_1\; x_1\; k_1 \mapsto c_1,\;
    \ldots,\;
    \op_n\; x_n\; k_n \mapsto c_n
  \}
\]

\noindent
Optionally, a handler may include type parameter instantiations $\$p_j \mapsto T_j$, which are collected into a substitution $\sigma = \{p_j \mapsto T_j\}_{j=1}^{m}$. When no parameter instantiations are present, $\sigma = \emptyset$.
\begin{mathpar}
  \inferrule{
    \cj{\G, x_r : A}{c_r}{B}{\Sig'}
    \\
    \Sig \setminus \{\op_1, \ldots, \op_n\} \subseteq \Sig'
    \\\\
    \left[
      (\op_i : A_i \leadsto B_i) \in \Sig \quad
      \cj{\G, x_i : A_i,\, k_i : \tfun{B_i}{\comp{B}{\Sig'}}}{c_i}{B}{\Sig'}
    \right]_{i = 1}^{n}
    }
    {\vj{\G}{
      \hhandler\;\{\ret x_r \mapsto c_r,\;
        \op_i\; x_i\; k_i \mapsto c_i,\;
        \$p_j \mapsto T_j
      \}
    }{\thandlerp{\comp{A}{\Sig}}{\sigma}{\comp{B}{\Sig'}}}}
    \quad (\textsc{Handler})
\end{mathpar}

The handler type $\thandlerp{\comp{A}{\Sig}}{\sigma}{\comp{B}{\Sig'}}$ indicates that the handler transforms computations of type $\comp{A}{\Sig}$ into computations of type $\comp{B}{\Sig'}$, instantiating type parameters according to $\sigma$.
The handled operations $\{\op_1, \ldots, \op_n\}$ must appear in~$\Sig$.
Unhandled operations are forwarded, requiring $\Sig \setminus \{\op_1, \ldots, \op_n\} \subseteq \Sig'$.

%% ═══════════════════════════════════════════════════════════════
\section{Computation Typing}\label{sec:computations}
%% ═══════════════════════════════════════════════════════════════

Rules for judgements of the form $\cj{\G}{c}{A}{\Sig}$.

\begin{mathpar}
  \inferrule
    {\vj{\G}{v}{A}}
    {\cj{\G}{\ret v}{A}{\Sig}}
    \quad (\textsc{Return})

  \inferrule
    {\cj{\G}{c_1}{A}{\Sig}
    \\
    \cj{\G, x : A}{c_2}{B}{\Sig}
    }
    {\cj{\G}{\ddo x \leftarrow c_1 \iin c_2}{B}{\Sig}}
    \quad (\textsc{Do})

  \inferrule
    {(\op : \arity{A_{\op}}{B_{\op}}) \in \Sig
    \\
    \vj{\G}{v}{A_{\op}}
    }
    {\cj{\G}{!\op \ v}{B_\op}{\Sig}}
    \quad (\textsc{Op})

  \inferrule
    {\vj{\G}{v}{\tbool}
    \\
    \cj{\G}{c_1}{A}{\Sig}
    \\
    \cj{\G}{c_2}{A}{\Sig}
    }
    {\cj{\G}{\iif v \then c_1 \eelse c_2}{A}{\Sig}}
    \quad (\textsc{If})

  \inferrule
    {\vj{\G}{v}{\teither{A}{B}}
    \\\\
    \cjp{\G, x_1 : A}{c_1}{C}
    \\
    \cjp{\G, x_2 : B}{c_2}{C}
    }
    {\cjp{\G}{\ccase v \oof \inl x_1 \to c_1,\; \inr x_2 \to c_2}{C}}
    \quad (\textsc{Case})

  \inferrule
    {\vj{\G}{v_1}{\tfun{A}{C}}
    \\
    \vj{\G}{v_2}{A}
    }
    {\cjp{\G}{v_1\; v_2}{C}}
    \quad (\textsc{App})

  \inferrule
    {\vj{\G}{v}{\thandlerp{C}{\sigma}{D}}
    \\
    \cjp{\G}{c}{C'}
    \\
    \sigma(C') = C
    \\
    \mathrm{dom}(\sigma) \cap \ftp(D) = \emptyset
    }
    {\cjp{\G}{\with v \handle c}{D}}
    \quad (\textsc{Handle})
\end{mathpar}

In the \textsc{Handle} rule, the body $c$ is typed with computation type $C'$, which may contain free type parameters in its effect signature.
The handler's substitution $\sigma$ is applied to $C'$, and the result must equal the handler's input type $C$.
This allows the body to use abstract type parameters (e.g., $\$q$) in its effect arities, which are resolved to concrete types (e.g., $\tunique$) by the handler's parameter instantiation.

When $\sigma = \emptyset$, the premise $\sigma(C') = C$ reduces to $C' = C$, recovering the standard handler application rule.
The final premise ensures that no operation in the output signature $\Sig'$ still references any type parameter being instantiated by $\sigma$.
This guarantees that operations whose arities depend on abstract type parameters are always handled by the handler that instantiates them, preventing the escape of uninstantiated parameters.

\end{document}
