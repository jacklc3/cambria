
@misc{lindley_scoped_2024,
	title = {Scoped {Effects} as {Parameterized} {Algebraic} {Theories}},
	url = {http://arxiv.org/abs/2402.03103},
	doi = {10.48550/arXiv.2402.03103},
	abstract = {Notions of computation can be modelled by monads. Algebraic effects offer a characterization of monads in terms of algebraic operations and equational axioms, where operations are basic programming features, such as reading or updating the state, and axioms specify observably equivalent expressions. However, many useful programming features depend on additional mechanisms such as delimited scopes or dynamically allocated resources. Such mechanisms can be supported via extensions to algebraic effects including scoped effects and parameterized algebraic theories. We present a fresh perspective on scoped effects by translation into a variation of parameterized algebraic theories. The translation enables a new approach to equational reasoning for scoped effects and gives rise to an alternative characterization of monads in terms of generators and equations involving both scoped and algebraic operations. We demonstrate the power of our fresh perspective by way of equational characterizations of several known models of scoped effects.},
	urldate = {2024-04-22},
	publisher = {arXiv},
	author = {Lindley, Sam and Matache, Cristina and Moss, Sean and Staton, Sam and Wu, Nicolas and Yang, Zhixuan},
	month = feb,
	year = {2024},
	note = {arXiv:2402.03103 [cs, math]},
	keywords = {Computer Science - Logic in Computer Science, Computer Science - Programming Languages, Mathematics - Category Theory},
}

@inproceedings{fiore_substitution_2014,
	address = {New York, NY, USA},
	series = {{CSL}-{LICS} '14},
	title = {Substitution, jumps, and algebraic effects},
	isbn = {978-1-4503-2886-9},
	url = {https://dl.acm.org/doi/10.1145/2603088.2603163},
	doi = {10.1145/2603088.2603163},
	abstract = {Algebraic structures abound in programming languages. The starting point for this paper is the following theorem: (first-order) algebraic signatures can themselves be described as free algebras for a (second-order) algebraic theory of substitution. Transporting this to the realm of programming languages, we investigate a computational metalanguage based on the theory of substitution, demonstrating that substituting corresponds to jumping in an abstract machine. We use the theorem to give an interpretation of a programming language with arbitrary algebraic effects into the metalanguage with substitution/jumps.},
	urldate = {2024-04-21},
	booktitle = {Proceedings of the {Joint} {Meeting} of the {Twenty}-{Third} {EACSL} {Annual} {Conference} on {Computer} {Science} {Logic} ({CSL}) and the {Twenty}-{Ninth} {Annual} {ACM}/{IEEE} {Symposium} on {Logic} in {Computer} {Science} ({LICS})},
	publisher = {Association for Computing Machinery},
	author = {Fiore, Marcelo and Staton, Sam},
	month = jul,
	year = {2014},
	pages = {1--10},
}

@article{launchbury_state_1995,
	title = {State in {Haskell}},
	url = {https://www.microsoft.com/en-us/research/publication/state-in-haskell/},
	abstract = {Some algorithms make critical internal use of updatable state, even though their external specification is purely functional. Based on earlier work on monads, we present a way of securely encapsulating stateful computations that manipulate multiple, named, mutable objects, in the context of a nonstrict, purely functional language. The security of the encapsulation is assured by […]},
	language = {en-US},
	urldate = {2024-04-09},
	journal = {Lisp and Symbolic Computation},
	author = {Launchbury, John and Jones, Simon Peyton},
	month = dec,
	year = {1995},
	pages = {293--342},
}

@article{liell-cock_let_2024,
	title = {Let a {Thousand} {Flowers} {Bloom}},
	volume = {8},
	issn = {2473-7321},
	url = {https://programming-journal.org/2024/8/9/},
	doi = {10.22152/programming-journal.org/2024/8/9},
	abstract = {Context: Edge graphs are graphs whose edges are labelled with identifiers, and nodes can have multiple edges between them. They are used to model a wide range of systems, including networks with distances or degrees of connection and complex relational data. Inquiry: Unfortunately, the homogeneit...},
	language = {en},
	number = {3},
	urldate = {2024-03-25},
	journal = {The Art, Science, and Engineering of Programming},
	author = {Liell-Cock, Jack and Schrijvers, Tom},
	month = feb,
	year = {2024},
	note = {Publisher: AOSA, Inc.},
	pages = {9:1--9:28},
}

@article{xie_first-class_2022,
	title = {First-class names for effect handlers},
	volume = {6},
	url = {https://dl.acm.org/doi/10.1145/3563289},
	doi = {10.1145/3563289},
	abstract = {Algebraic effects and handlers are a promising technique for incorporating composable computational effects into functional programming languages. Effect handlers enable concisely programming with different effects, but they do not offer a convenient way to program with different instances of the same effect. As a solution to this inconvenience, previous studies have introduced \_named effect handlers\_, which allow the programmer to distinguish among different effect instances. However, existing formalizations of named handlers are both involved and restrictive, as they employ non-standard mechanisms to prevent the escaping of handler names. In this paper, we propose a simple and flexible design of named handlers. Specifically, we treat handler names as first-class values, and prevent their escaping while staying within the ordinary λ-calculus. Such a design is enabled by combining named handlers with \_scoped effects\_, a novel variation of effects that maintain a scope via rank-2 polymorphism. We formalize two combinations of named handlers and scoped effects, and implement them in the Koka programming language. We also present practical applications of named handlers, including a neural network and a unification algorithm.},
	number = {OOPSLA2},
	urldate = {2024-03-19},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Xie, Ningning and Cong, Youyou and Ikemori, Kazuki and Leijen, Daan},
	month = oct,
	year = {2022},
	keywords = {Algebraic Effects, Effect Handlers, Scoping},
	pages = {126:30--126:59},
}

@article{bauer_effect_2014,
	title = {An {Effect} {System} for {Algebraic} {Effects} and {Handlers}},
	volume = {Volume 10, Issue 4},
	issn = {1860-5974},
	url = {https://lmcs.episciences.org/1153},
	doi = {10.2168/LMCS-10(4:9)2014},
	abstract = {We present an effect system for core Eff, a simplified variant of Eff, which is an ML-style programming language with first-class algebraic effects and handlers. We define an expressive effect system and prove safety of operational semantics with respect to it. Then we give a domain-theoretic denotational semantics of core Eff, using Pitts's theory of minimal invariant relations, and prove it adequate. We use this fact to develop tools for finding useful contextual equivalences, including an induction principle. To demonstrate their usefulness, we use these tools to derive the usual equations for mutable state, including a general commutativity law for computations using non-interfering references. We have formalized the effect system, the operational semantics, and the safety theorem in Twelf.},
	urldate = {2024-02-21},
	journal = {Logical Methods in Computer Science},
	author = {Bauer, Andrej and Pretnar, Matija},
	month = dec,
	year = {2014},
	note = {Publisher: Episciences.org},
}

@article{kammar_no_2017,
	title = {No value restriction is needed for algebraic effects and handlers},
	volume = {27},
	issn = {0956-7968},
	url = {https://ora.ox.ac.uk/objects/uuid:41c04594-0d79-4b81-ab31-da032f036bd9},
	abstract = {We present a straightforward, sound, Hindley-Milner polymorphic type system for algebraic effects and handlers in a call-by-value calculus, which, to our surprise, allows type variable generalisation of arbitrary computations, and not just values. We first recall that the soundness of unrestricted call-by-value Hindley-Milner polymorphism is known to fail in the presence of computational effects such as reference cells and continuations, and that many programming examples can be recast to use effect handlers instead of these effects. After presenting the calculus and its soundness proof, formalised in Twelf, we analyse the expressive power of effect handlers with respect to state effects. We conjecture handlers alone cannot express reference cells, but show they can simulate dynamically scoped state, establishing that dynamic binding also does not need a value restriction.},
	language = {en},
	number = {e7},
	urldate = {2024-02-21},
	journal = {Journal of Functional Programming},
	author = {Kammar, O. and Pretnar, M.},
	year = {2017},
	note = {Publisher: Cambridge University Press},
}

@article{kock_strong_1972,
	title = {Strong functors and monoidal monads},
	volume = {23},
	issn = {1420-8938},
	url = {https://doi.org/10.1007/BF01304852},
	doi = {10.1007/BF01304852},
	language = {en},
	number = {1},
	urldate = {2024-02-16},
	journal = {Archiv der Mathematik},
	author = {Kock, Anders},
	month = dec,
	year = {1972},
	pages = {113--120},
}

@article{gischer_equational_1988,
	title = {The equational theory of pomsets},
	volume = {61},
	issn = {0304-3975},
	url = {https://www.sciencedirect.com/science/article/pii/0304397588901247},
	doi = {10.1016/0304-3975(88)90124-7},
	abstract = {Pomsets have been introduced as a model of concurrency. Since a pomset is a string in which the total order has been relaxed to be a partial order, in this paper we view them as a generalization of strings, and investigate their algebraic properties. In particular, we investigate the axiomatic properties of pomsets, sets of pomsets and ideals of pomsets, under such operations as concatenation, parallel composition, union and their associated closure operations. We find that the equational theory of sets, pomsets under concatenation, parallel composition and union is finitely axiomatizable, whereas the theory of languages under the analogous operations is not. A similar result is obtained for ideals of pomsets, which incorporate the notion of subsumption which is also known as augmentation. Finally, we show that the addition of any closure operation (parallel or serial) leads to nonfinite axiomatizability of the resulting equational theory.},
	number = {2},
	urldate = {2024-02-08},
	journal = {Theoretical Computer Science},
	author = {Gischer, Jay L.},
	month = nov,
	year = {1988},
	pages = {199--224},
}

@article{backhouse_regular_1975,
	title = {Regular algebra applied to path-finding problems},
	volume = {15},
	issn = {0272-4960},
	url = {https://doi.org/10.1093/imamat/15.2.161},
	doi = {10.1093/imamat/15.2.161},
	abstract = {In an earlier paper, one of the authors presented an algebra for formulating and solving extremal path problems. There are striking similarities between that algebra and the algebra of regular languages, which lead one to consider whether the previous results can be generalized—for instance to path enumeration problems—and whether the algebra of regular languages can itself be profitably used for the general study of path-finding problems. This paper gives affirmative answers to both these questions.},
	number = {2},
	journal = {IMA Journal of Applied Mathematics},
	author = {Backhouse, Roland and Carre, B. A.},
	month = apr,
	year = {1975},
	pages = {161--186},
}

@inproceedings{winskel_new-hopla_2004,
	address = {Boston, MA},
	series = {{IFIP} {International} {Federation} for {Information} {Processing}},
	title = {New-{HOPLA} a higher-order process language with name generation},
	isbn = {978-1-4020-8141-5},
	doi = {10.1007/1-4020-8141-3_40},
	abstract = {This paper introduces new-HOPLA, a concise but powerful language for higherorder nondeterministic processes with name generation. Its origins as a metalanguage for domain theory are sketched but for the most part the paper concentrates on its operational semantics. The language is typed, the type of a process describing the shape of the computation paths it can perform. Its transition semantics, bisimulation, congruence properties and expressive power are explored. Encodings are given of well-known process algebras, including π-calculus, Higher-Order π-calculus and Mobile Ambients.},
	language = {en},
	booktitle = {Exploring {New} {Frontiers} of {Theoretical} {Informatics}},
	publisher = {Springer US},
	author = {Winskel, Glynn and Nardelli, Francesco Zappa},
	editor = {Levy, Jean-Jacques and Mayr, Ernst W. and Mitchell, John C.},
	year = {2004},
	keywords = {Computation Path, Domain Theory, Operational Semantic, Parallel Composition, Transition Rule},
	pages = {521--534},
}

@inproceedings{nygaard_full_2003,
	address = {Berlin, Heidelberg},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Full {Abstraction} for {HOPLA}},
	isbn = {978-3-540-45187-7},
	doi = {10.1007/978-3-540-45187-7_25},
	abstract = {A fully abstract denotational semantics for the higher-order process language HOPLA is presented. It characterises contextual and logical equivalence, the latter linking up with simulation. The semantics is a clean, domain-theoretic description of processes as downwards-closed sets of computation paths: the operations of HOPLA arise as syntactic encodings of canonical constructions on such sets; full abstraction is a direct consequence of expressiveness with respect to computation paths; and simple proofs of soundness and adequacy shows correspondence between the denotational and operational semantics.},
	language = {en},
	booktitle = {{CONCUR} 2003 - {Concurrency} {Theory}},
	publisher = {Springer},
	author = {Nygaard, Mikkel and Winskel, Glynn},
	editor = {Amadio, Roberto and Lugiez, Denis},
	year = {2003},
	keywords = {Closed Term, Computation Path, Denotational Semantic, Linear Logic, Operational Semantic},
	pages = {383--398},
}

@inproceedings{winskel_event_1987,
	address = {Berlin, Heidelberg},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Event structures},
	isbn = {978-3-540-47926-0},
	doi = {10.1007/3-540-17906-2_31},
	abstract = {Event structures are a model of computational processes. They represent a process as a set of event occurrences with relations to express how events causally depend on others. This paper introduces event structures, shows their relationship to Scott domains and Petri nets, and surveys their role in denotational semantics, both for modelling languages like CCS and CSP and languages with higher types.},
	language = {en},
	booktitle = {Petri {Nets}: {Applications} and {Relationships} to {Other} {Models} of {Concurrency}},
	publisher = {Springer},
	author = {Winskel, Glynn},
	editor = {Brauer, W. and Reisig, W. and Rozenberg, G.},
	year = {1987},
	keywords = {Denotational Semantic, Event Structure, Parallel Composition, Partial Order, Prime Interval},
	pages = {325--392},
}

@article{nielsen_petri_1996,
	title = {Petri nets and bisimulation},
	volume = {153},
	issn = {0304-3975},
	url = {https://www.sciencedirect.com/science/article/pii/0304397595001220},
	doi = {10.1016/0304-3975(95)00122-0},
	abstract = {Several categorical relationships (adjunctions) between models for concurrency have been established, allowing the translation of concepts and properties from one model to another. A central example is a coreflection between Petri nets and asynchronous transition systems. The purpose of the present paper is to illustrate the use of such relationships by transferring to Petri nets a general concept of bisimulation.},
	number = {1},
	urldate = {2023-11-30},
	journal = {Theoretical Computer Science},
	author = {Nielsen, Mogens and Winskel, Glynn},
	month = jan,
	year = {1996},
	pages = {211--244},
}

@article{mcbride_derivative_2009,
	title = {The {Derivative} of a {Regular} {Type} is its {Type} of {One}-{Hole} {Contexts}},
	abstract = {Polymorphic regular types are tree-like datatypes gen-erated by polynomial type expressions over a set of free variables and closed under least fixed point. The 'equal-ity types' of Core ML can be expressed in this form. Given such a type expression T with x free, this paper shows a way to represent the one-hole contexts for elements of x within elements of T, together with an operation which will plug an element of x into the hole of such a context. One-hole contexts are given as inhabitants of a regular type @ x T, computed generically from the syntactic struc-ture of T by a mechanism better known as partial differ-entiation. The relevant notion of containment is shown to be appropriately characterized in terms of derivatives and plugging in. The technology is then exploited to give the one-hole contexts for sub-elements of recursive types in a manner similar to Huet's 'zippers'[Hue97].},
	language = {en},
	author = {McBride, Conor},
	year = {2009},
	pages = {11},
}

@article{mcbride_view_2004,
	title = {The view from the left},
	volume = {14},
	issn = {1469-7653, 0956-7968},
	url = {https://ezproxy-prd.bodleian.ox.ac.uk:2117/core/journals/journal-of-functional-programming/article/view-from-the-left/F8A44CAC27CCA178AF69DD84BC585A2D},
	doi = {10.1017/S0956796803004829},
	abstract = {Pattern matching has proved an extremely powerful and durable notion in functional programming. This paper contributes a new programming notation for type theory which elaborates the notion in various ways. First, as is by now quite well-known in the type theory community, definition by pattern matching becomes a more discriminating tool in the presence of dependent types, since it refines the explanation of types as well as values. This becomes all the more true in the presence of the rich class of datatypes known as inductive families (Dybjer, 1991). Secondly, as proposed by Peyton Jones (1997) for Haskell, and independently rediscovered by us, subsidiary case analyses on the results of intermediate computations, which commonly take place on the right-hand side of definitions by pattern matching, should rather be handled on the left. In simply-typed languages, this subsumes the trivial case of Boolean guards; in our setting it becomes yet more powerful. Thirdly, elementary pattern matching decompositions have a well-defined interface given by a dependent type; they correspond to the statement of an induction principle for the datatype. More general, user-definable decompositions may be defined which also have types of the same general form. Elementary pattern matching may therefore be recast in abstract form, with a semantics given by translation. Such abstract decompositions of data generalize Wadler's (1987) notion of ‘view’. The programmer wishing to introduce a new view of a type . We develop enough syntax and semantics to account for this high-level style of programming in dependent type theory. We close with the development of a typechecker for the simply-typed lambda calculus, which furnishes a view of raw terms as either being well-typed, or containing an error. The implementation of this view is ipso facto a proof that typechecking is decidable.},
	language = {en},
	number = {1},
	urldate = {2022-11-23},
	journal = {Journal of Functional Programming},
	author = {McBride, Conor and McKinna, James},
	month = jan,
	year = {2004},
	note = {Publisher: Cambridge University Press},
	pages = {69--111},
}

@unpublished{knight_godel_2022,
	address = {Oxford},
	type = {Lecture notes},
	title = {The {Godel} {Incompleteness} {Theorems}},
	language = {en},
	author = {Knight, Robert W.},
	year = {2022},
}

@inproceedings{linton_aspects_1966,
	address = {Berlin, Heidelberg},
	title = {Some {Aspects} of {Equational} {Categories}},
	isbn = {978-3-642-99902-4},
	doi = {10.1007/978-3-642-99902-4_3},
	abstract = {The theory of equationally definable classes of algebras, initiated by Birkhoff in the early thirties, is, despite its power, elegance and simplicity, hampered in its usefulness by two defects. The first is its refusal to deal with infinitary operations; the second is the awkwardness inherent in the presentation of an equationally definable class in terms of operations and equations.},
	language = {en},
	booktitle = {Proceedings of the {Conference} on {Categorical} {Algebra}},
	publisher = {Springer},
	author = {Linton, Fred E. J.},
	editor = {Eilenberg, Samuel and Harrison, David K. and Mac Lane, Saunders and Röhrl, Helmut},
	year = {1966},
	pages = {84--94},
}

@inproceedings{wadler_views_1987,
	address = {New York, NY, USA},
	series = {{POPL} '87},
	title = {Views: a way for pattern matching to cohabit with data abstraction},
	isbn = {978-0-89791-215-0},
	shorttitle = {Views},
	url = {https://ezproxy-prd.bodleian.ox.ac.uk:2102/10.1145/41625.41653},
	doi = {10.1145/41625.41653},
	abstract = {Pattern matching and data abstraction are important concepts in designing programs, but they do not fit well together. Pattern matching depends on making public a free data type representation, while data abstraction depends on hiding the representation. This paper proposes the views mechanism as a means of reconciling this conflict. A view allows any type to be viewed as a free data type, thus combining the clarity of pattern matching with the efficiency of data abstraction.},
	urldate = {2022-11-30},
	booktitle = {Proceedings of the 14th {ACM} {SIGACT}-{SIGPLAN} symposium on {Principles} of programming languages},
	publisher = {Association for Computing Machinery},
	author = {Wadler, Philip},
	month = oct,
	year = {1987},
	pages = {307--313},
}

@misc{yorgey_unordered_2012,
	title = {Unordered tuples and type algebra},
	url = {https://byorgey.wordpress.com/2012/08/24/unordered-tuples-and-type-algebra/},
	abstract = {At Hac Phi a few weekends ago (which, by the way, was awesome), Dan Doel told me about a certain curiosity in type algebra, and we ended up working out a bunch more details together with Gershom Ba…},
	language = {en},
	urldate = {2022-11-28},
	journal = {blog :: Brent -{\textgreater} [String]},
	author = {Yorgey, Brent A.},
	month = aug,
	year = {2012},
}

@article{gibbons_third_1996,
	title = {The {Third} {Homomorphism} {Theorem}},
	volume = {6},
	issn = {0956-7968},
	abstract = {The Third Homomorphism Theorem is a folk theorem of the constructive algorithmics community. It states that a function on lists that can be computed both from left to right and from right to left is necessarily a list homomorphism - it can be computed according to any parenthesization of the list. We formalize and prove the theorem, and use it to improve an O(n2) sorting algorithm to O(n log n).},
	language = {eng},
	journal = {Journal of Functional Programming},
	author = {Gibbons, Jeremy},
	year = {1996},
}

@misc{yorgey_species_2010,
	title = {Species subtraction made simple},
	url = {https://byorgey.wordpress.com/2010/11/24/species-subtraction-made-simple/},
	abstract = {{\textgreater} \{-\# OPTIONS\_GHC -fno-warn-missing-methods \#-\} {\textgreater} module Virtual where {\textgreater} {\textgreater} import Control.Applicative {\textgreater} import Test.QuickCheck Yesterday on \#haskell, augur asked me to explain how su…},
	language = {en},
	urldate = {2022-11-28},
	journal = {blog :: Brent -{\textgreater} [String]},
	author = {Yorgey, Brent A.},
	month = nov,
	year = {2010},
}

@article{yorgey_species_2010-1,
	title = {Species and {Functors} and {Types}, {Oh} {My}},
	volume = {45},
	issn = {1523-2867},
	doi = {10.1145/2088456.1863542},
	abstract = {The theory of
combinatorial species
, although invented as a purely mathematical formalism to unify much of combinatorics, can also serve as a powerful and expressive language for talking about data types. With potential applications to automatic test generation, generic programming, and language design, the theory deserves to be much better known in the functional programming community. This paper aims to teach the basic theory of combinatorial species using motivation and examples from the world of functional programming. It also introduces the
species
library, available on Hackage, which is used to illustrate the concepts introduced and can serve as a platform for continued study and research.},
	language = {eng},
	number = {11},
	journal = {ACM SIGPLAN notices},
	author = {Yorgey, Brent A.},
	year = {2010},
	note = {Place: New York, NY
Publisher: Association for Computing Machinery},
	keywords = {Applied sciences, Computer science; control theory; systems, Exact sciences and technology, Programming languages, Software},
	pages = {147--158},
}

@book{mac_lane_sheaves_1994,
	address = {New York, NY, UNITED STATES},
	title = {Sheaves in {Geometry} and {Logic}: {A} {First} {Introduction} to {Topos} {Theory}},
	isbn = {978-1-4612-0927-0},
	shorttitle = {Sheaves in {Geometry} and {Logic}},
	url = {http://ebookcentral.proquest.com/lib/oxford/detail.action?docID=3074007},
	abstract = {We dedicate this book to the memory of J. Frank Adams. His clear insights have inspired many mathematicians, including both of us. In January 1989, when the first draft of our book had been completed, we heard the sad news of his untimely death. This has cast a shadow on our subsequent work. Our views of topos theory, as presented here, have been shaped by continued study, by conferences, and by many personal contacts with friends and colleagues-including especially O. Bruno, P. Freyd, J.M.E. Hyland, P.T. Johnstone, A. Joyal, A. Kock, F.W. Lawvere, G.E. Reyes, R Solovay, R Swan, RW. Thomason, M. Tierney, and G.C. Wraith. Our presentation combines ideas and results from these people and from many others, but we have not endeavored to specify the various original sources. Moreover, a number of people have assisted in our work by pro viding helpful comments on portions of the manuscript. In this respect, we extend our hearty thanks in particular to P. Corazza, K. Edwards, J. Greenlees, G. Janelidze, G. Lewis, and S. Schanuel.},
	urldate = {2023-01-11},
	publisher = {Springer New York},
	author = {Mac Lane, Saunders and Moerdijk, Ieke},
	year = {1994},
	keywords = {Toposes.},
}

@article{plotkin_semantics_2001,
	series = {{MFPS} 2001,{Seventeenth} {Conference} on the {Mathematical} {Foundations} of {Programming} {Semantics}},
	title = {Semantics for {Algebraic} {Operations}},
	volume = {45},
	issn = {1571-0661},
	url = {https://www.sciencedirect.com/science/article/pii/S1571066104809708},
	doi = {10.1016/S1571-0661(04)80970-8},
	abstract = {Given a category C with finite products and a strong monad T on C, we investigate axioms under which an ObC-indexed family of operations of the form αx:(Tx)n → Tx provides a definitive semantics for algebraic operations added to the computational λ-calculus. We recall a definition for which we have elsewhere given adequacy results for both big and small step operational semantics, and we show that it is equivalent to a range of other possible natural definitions of algebraic operation. We outline examples and non-examples and we show that our definition is equivalent to one for call-by-name languages with effects, too.},
	language = {en},
	urldate = {2023-04-24},
	journal = {Electronic Notes in Theoretical Computer Science},
	author = {Plotkin, Gordon D. and Power, John},
	month = nov,
	year = {2001},
	pages = {332--345},
}

@inproceedings{sivaramakrishnan_retrofitting_2021,
	address = {New York, NY, USA},
	series = {{PLDI} 2021},
	title = {Retrofitting effect handlers onto {OCaml}},
	isbn = {978-1-4503-8391-2},
	url = {https://dl.acm.org/doi/10.1145/3453483.3454039},
	doi = {10.1145/3453483.3454039},
	abstract = {Effect handlers have been gathering momentum as a mechanism for modular programming with user-defined effects. Effect handlers allow for non-local control flow mechanisms such as generators, async/await, lightweight threads and coroutines to be composably expressed. We present a design and evaluate a full-fledged efficient implementation of effect handlers for OCaml, an industrial-strength multi-paradigm programming language. Our implementation strives to maintain the backwards compatibility and performance profile of existing OCaml code. Retrofitting effect handlers onto OCaml is challenging since OCaml does not currently have any non-local control flow mechanisms other than exceptions. Our implementation of effect handlers for OCaml: (i) imposes a mean 1\% overhead on a comprehensive macro benchmark suite that does not use effect handlers; (ii) remains compatible with program analysis tools that inspect the stack; and (iii) is efficient for new code that makes use of effect handlers.},
	urldate = {2023-11-01},
	booktitle = {Proceedings of the 42nd {ACM} {SIGPLAN} {International} {Conference} on {Programming} {Language} {Design} and {Implementation}},
	publisher = {Association for Computing Machinery},
	author = {Sivaramakrishnan, K. C. and Dolan, Stephen and White, Leo and Kelly, Tom and Jaffer, Sadiq and Madhavapeddy, Anil},
	month = jun,
	year = {2021},
	keywords = {Backtraces, Backwards compatibility, Continuations, Effect handlers, Fibers},
	pages = {206--221},
}

@inproceedings{gibbons_relational_2018,
	title = {Relational algebra by way of adjunctions},
	isbn = {2475-1421},
	doi = {10.1145/3236781},
	abstract = {Bulk types such as sets, bags, and lists are monads, and therefore support a notation for database queries based on comprehensions. This fact is the basis of much work on database query languages. The monadic structure easily explains most of standard relational algebra---specifically, selections and projections---allowing for an elegant mathematical foundation for those aspects of database query language design. Most, but not all: monads do not immediately offer an explanation of relational join or grouping, and hence important foundations for those crucial aspects of relational algebra are missing. The best they can offer is cartesian product followed by selection. Adjunctions come to the rescue: like any monad, bulk types also arise from certain adjunctions; we show that by paying due attention to other important adjunctions, we can elegantly explain the rest of standard relational algebra. In particular, graded monads provide a mathematical foundation for indexing and grouping, which leads directly to an efficient implementation, even of joins.},
	language = {eng},
	publisher = {Association for Computing Machinery ACM},
	author = {Gibbons, Jeremy and Henglein, Fritz and Hinze, Ralf and Wu, Nicolas},
	year = {2018},
	keywords = {Computer Science, Computer Science, Software Engineering, SQL, Science \& Technology, Technology, adjunction, comprehension, graded monad, monad},
}

@article{ursu_recursive_2000,
	title = {Recursive inseparability of the sets of identically valid and finitely refutable formulas of some elementary theories of varieties},
	volume = {41},
	issn = {1573-9260},
	url = {https://doi.org/10.1007/BF02674114},
	doi = {10.1007/BF02674114},
	language = {en},
	number = {3},
	urldate = {2023-04-21},
	journal = {Siberian Mathematical Journal},
	author = {Ursu, Vasile I.},
	month = jun,
	year = {2000},
	keywords = {Elementary Theory, Free Generator, Moufang Loop, Object Symbol, Unary Operation},
	pages = {578--591},
}

@inproceedings{selinger_order-incompleteness_1996,
	title = {Order-incompleteness and finite lambda models},
	doi = {10.1109/LICS.1996.561459},
	abstract = {Many familiar models of the type-free lambda calculus are constructed by order theoretic methods. This paper provides some basic new facts about ordered models of the lambda calculus. We show that in any partially ordered model that is complete for the theory of /spl beta/- or /spl beta//spl eta/-conversion, the partial order is trivial on term denotations. Equivalently, the open and closed term algebras of the type-free lambda calculus cannot be non-trivially partially ordered. Our second result is a syntactical characterization, in terms of so-called generalized Mal'cev operators, of those lambda theories which cannot be induced by any non-trivially partially ordered model. We also consider a notion of finite models for the type-free lambda calculus. We introduce partial syntactical lambda models, which are derived from Plotkin's syntactical models of reduction, and we investigate how these models can be used as practical tools for giving finitary proofs of term inequalities. We give a 3-element model as an example.},
	booktitle = {Proceedings 11th {Annual} {IEEE} {Symposium} on {Logic} in {Computer} {Science}},
	author = {Selinger, Peter},
	month = jul,
	year = {1996},
	note = {ISSN: 1043-6871},
	keywords = {Algebra, Art, Calculus, Cognitive science, Mathematical model, Mathematical programming, Mathematics},
	pages = {432--439},
}

@incollection{plotkin_notions_2002,
	address = {Berlin, Heidelberg},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Notions of {Computation} {Determine} {Monads}},
	isbn = {978-3-540-43366-8},
	abstract = {We model notions of computation using algebraic operations and equations. We show that these generate several of the monads of primary interest that have been used to model computational effects, with the striking omission of the continuations monad. We focus on semantics for global and local state, showing that taking operations and equations as primitive yields a mathematical relationship that reflects their computational relationship.},
	language = {eng},
	booktitle = {Foundations of {Software} {Science} and {Computation} {Structures}},
	publisher = {Springer Berlin Heidelberg},
	author = {Plotkin, Gordon D. and Power, John},
	year = {2002},
	doi = {10.1007/3-540-45931-6_24},
	note = {ISSN: 0302-9743},
	keywords = {Algebraic Operation, Algorithmics. Computability. Computer arithmetics, Applied sciences, Closed Structure, Computer science; control theory; systems, Countable Product, Exact sciences and technology, Forgetful Functor, Global State, Theoretical computing},
	pages = {342--356},
}

@inproceedings{benton_linear_1996,
	title = {Linear logic, monads and the lambda calculus},
	doi = {10.1109/LICS.1996.561458},
	abstract = {Models of intuitionistic linear logic also provide models of Moggi's computational metalanguage. We use the adjoint presentation of these models and the associated adjoint calculus to show that three translations, due mainly to Moggi, of the lambda calculus into the computational metalanguage (direct, call-by-name and call-by-value) correspond exactly to three translations, due mainly to Girard, of intuitionistic logic into intuitionistic linear logic. We also consider extending these results to languages with recursion.},
	booktitle = {Proceedings 11th {Annual} {IEEE} {Symposium} on {Logic} in {Computer} {Science}},
	author = {Benton, Nick and Wadler, Philip},
	month = jul,
	year = {1996},
	note = {ISSN: 1043-6871},
	keywords = {Calculus, Computational modeling, Ear, Laboratories, Logic, Proposals},
	pages = {420--431},
}

@incollection{plotkin_handlers_2009,
	address = {Berlin, Heidelberg},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Handlers of {Algebraic} {Effects}},
	isbn = {978-3-642-00589-3},
	abstract = {We present an algebraic treatment of exception handlers and, more generally, introduce handlers for other computational effects representable by an algebraic theory. These include nondeterminism, interactive input/output, concurrency, state, time, and their combinations; in all cases the computation monad is the free-model monad of the theory. Each such handler corresponds to a model of the theory for the effects at hand. The handling construct, which applies a handler to a computation, is based on the one introduced by Benton and Kennedy, and is interpreted using the homomorphism induced by the universal property of the free model. This general construct can be used to describe previously unrelated concepts from both theory and practice.},
	language = {eng},
	booktitle = {Programming {Languages} and {Systems}},
	publisher = {Springer Berlin Heidelberg},
	author = {Plotkin, Gordon D. and Pretnar, Matija},
	year = {2009},
	doi = {10.1007/978-3-642-00590-9_7},
	note = {ISSN: 0302-9743},
	keywords = {Algebraic Theory, Base Signature, Base Type, Function Symbol, Relation Symbol},
	pages = {80--94},
}

@article{oliveira_functional_2012,
	title = {Functional programming with structured graphs},
	volume = {47},
	issn = {0362-1340},
	doi = {10.1145/2398856.2364541},
	abstract = {This paper presents a new functional programming model for graph structures called structured graphs . Structured graphs extend conventional algebraic datatypes with explicit definition and manipulation of cycles and/or sharing, and offer a practical and convenient way to program graphs in functional programming languages like Haskell. The representation of sharing and cycles (edges) employs recursive binders and uses an encoding inspired by parametric higher-order abstract syntax . Unlike traditional approaches based on mutable references or node/edge lists, well-formedness of the graph structure is ensured statically and reasoning can be done with standard functional programming techniques. Since the binding structure is generic, we can define many useful generic combinators for manipulating structured graphs. We give applications and show how to reason about structured graphs.},
	language = {eng},
	number = {9},
	journal = {SIGPLAN notices},
	author = {Oliveira, Bruno C. d. S. and Cook, William R.},
	year = {2012},
	pages = {77--88},
}

@article{kleisli_every_1965,
	title = {Every {Standard} {Construction} is {Induced} by a {Pair} of {Adjoint} {Functors}},
	volume = {16},
	issn = {0002-9939},
	doi = {10.1090/S0002-9939-1965-0177024-4},
	language = {eng},
	number = {3},
	journal = {Proceedings of the American Mathematical Society},
	author = {Kleisli, Heinrich},
	year = {1965},
	note = {Publisher: American Mathematical Society},
	keywords = {Adjoints, Functors, Morphisms},
	pages = {544--546},
}

@article{matache_concrete_2022,
	title = {Concrete categories and higher-order recursion ({With} applications including probability, differentiability, and full abstraction)},
	url = {https://arxiv.org/abs/2205.15917},
	doi = {10.1145/3531130.3533370},
	abstract = {We study concrete sheaf models for a call-by-value higher-order language with
recursion. Our family of sheaf models is a generalization of many examples from
the literature, such as models for probabilistic and differentiable
programming, and fully abstract logical relations models. We treat recursion in
the spirit of synthetic domain theory. We provide a general construction of a
lifting monad starting from a class of admissible monomorphisms in the site of
the sheaf category. In this way, we obtain a family of models parametrized by a
concrete site and a class of monomorphisms, for which we prove a general
computational adequacy theorem.},
	language = {eng},
	urldate = {2022-11-07},
	author = {Matache, Cristina and Moss, Sean K. and Staton, Sam},
	year = {2022},
}

@inproceedings{moggi_computational_1989,
	address = {Pacific Grove, CA, USA},
	title = {Computational lambda-calculus and monads},
	isbn = {978-0-8186-1954-0},
	url = {http://ieeexplore.ieee.org/document/39155/},
	doi = {10.1109/LICS.1989.39155},
	abstract = {The λ-calculus is considered an useful mathematical tool in the study of programming languages. However, if one uses βη-conversion to prove equivalence of programs, then a gross simpliﬁcation1 is introduced. We give a calculus based on a categorical semantics for computations, which provides a correct basis for proving equivalence of programs, independent from any speciﬁc computational model.},
	language = {en},
	urldate = {2023-06-14},
	booktitle = {[1989] {Proceedings}. {Fourth} {Annual} {Symposium} on {Logic} in {Computer} {Science}},
	publisher = {IEEE Comput. Soc. Press},
	author = {Moggi, Eugenio},
	year = {1989},
	pages = {14--23},
}

@article{plotkin_computational_2004,
	title = {Computational {Effects} and {Operations}: {An} {Overview}},
	volume = {73},
	issn = {1571-0661},
	shorttitle = {Computational {Effects} and {Operations}},
	doi = {10.1016/j.entcs.2004.08.008},
	language = {eng},
	journal = {Electronic notes in theoretical computer science},
	author = {Plotkin, Gordon D. and Power, John},
	year = {2004},
	note = {Publisher: Elsevier B.V},
	pages = {149--163},
}

@article{gibbons_comprehending_2016,
	title = {Comprehending {Ringads}},
	volume = {9600},
	issn = {9783319309354},
	url = {https://ora.ox.ac.uk/objects/uuid:1dc006fd-8896-4979-b3ad-45bc542ea8f0},
	abstract = {List comprehensions are a widely used programming construct, in languages such as Haskell and Python and in technologies such as Microsoft’s Language Integrated Query. They generalize from lists to arbitrary monads, yielding a lightweight idiom of imperative programming in a pure functional language. When the monad has the additional structure of a so-called ringad, corresponding to ‘empty’ and ‘union’ operations, then it can be seen as some kind of collection type, and the comprehension notation can also be extended to incorporate aggregations. Ringad comprehensions represent a convenient notation for expressing database queries. The ringad structure alone does not provide a good explanation or an efficient implementation of relational joins; but by allowing heterogeneous comprehensions, involving both bag and indexed table ringads, we show how to accommodate these too.},
	language = {en},
	urldate = {2022-11-08},
	journal = {A List of Successes That Can Change the World: Essays Dedicated to Philip Wadler on the Occasion of His 60th Birthday},
	author = {Gibbons, Jeremy},
	year = {2016},
}

@inproceedings{simpson_complete_2000,
	title = {Complete axioms for categorical fixed-point operators},
	isbn = {978-0-7695-0725-5},
	url = {https://ieeexplore.ieee.org/document/855753},
	doi = {10.1109/LICS.2000.855753},
	abstract = {We give an axiomatic treatment of fixed-point operators in categories. A notion of iteration operator is defined embodying the equational properties of iteration theories. We prove a general completeness theorem for iteration operators, relying on a new, purely syntactic characterisation of the free iteration theory. We then show how iteration operators arise in axiomatic domain theory. One result derives them from the existence of sufficiently many bifree algebras (exploiting the universal property Freyd introduced in his notion of algebraic compactness). Another result shows that, in the presence of a parameterized natural numbers object and an equational lifting monad, any uniform fixed-point operator is necessarily an iteration operator.},
	language = {eng},
	urldate = {2023-10-10},
	booktitle = {Proceedings {Fifteenth} {Annual} {IEEE} {Symposium} on {Logic} in {Computer} {Science}},
	publisher = {IEEE},
	author = {Simpson, Alex and Plotkin, Gordon D.},
	year = {2000},
	keywords = {Equations, Informatics, National electric code},
	pages = {30--41},
}

@misc{van_den_berg_framework_2023,
	title = {A {Framework} for {Higher}-{Order} {Effects} \& {Handlers}},
	url = {http://arxiv.org/abs/2302.01415},
	doi = {10.48550/arXiv.2302.01415},
	abstract = {Algebraic effects \& handlers are a modular approach for modeling side-effects in functional programming. Their syntax is defined in terms of a signature of effectful operations, encoded as a functor, that are plugged into the free monad; their denotational semantics is defined by fold-style handlers that only interpret their part of the syntax and forward the rest. However, not all effects are algebraic: some need to access an internal computation. For example, scoped effects distinguish between a computation in scope and out of scope; parallel effects parallellize over a computation, latent effects defer a computation. Separate definitions have been proposed for these higher-order effects and their corresponding handlers, often leading to expedient and complex monad definitions. In this work we propose a generic framework for higher-order effects, generalizing algebraic effects \& handlers: a generic free monad with higher-order effect signatures and a corresponding interpreter. Specializing this higher-order syntax leads to various definitions of previously defined (scoped, parallel, latent) and novel (writer, bracketing) effects. Furthermore, we formally show our framework theoretically correct, also putting different effect instances on formal footing; a significant contribution for parallel, latent, writer and bracketing effects.},
	urldate = {2023-10-19},
	publisher = {arXiv},
	author = {van den Berg, Birthe and Schrijvers, Tom},
	month = feb,
	year = {2023},
	note = {arXiv:2302.01415 [cs]},
	keywords = {Computer Science - Logic in Computer Science, Computer Science - Programming Languages},
}

@misc{bosman_calculus_2023,
	title = {A {Calculus} for {Scoped} {Effects} \& {Handlers}},
	url = {http://arxiv.org/abs/2304.09697},
	doi = {10.48550/arXiv.2304.09697},
	abstract = {Algebraic effects \& handlers have become a standard approach for side-effects in functional programming. Their modular composition with other effects and clean separation of syntax and semantics make them attractive to a wide audience. However, not all effects can be classified as algebraic; some need a more sophisticated handling. In particular, effects that have or create a delimited scope need special care, as their continuation consists of two parts-in and out of the scope-and their modular composition introduces additional complexity. These effects are called scoped and have gained attention by their growing applicability and adoption in popular libraries. While calculi have been designed with algebraic effects \& handlers built in to facilitate their use, a calculus that supports scoped effects \& handlers in a similar manner does not yet exist. This work fills this gap: we present \${\textbackslash}lambda\_\{{\textbackslash}mathit\{sc\}\}\$, a calculus with native support for both algebraic and scoped effects \& handlers. It addresses the need for polymorphic handlers and explicit clauses for forwarding unknown scoped operations to other handlers. Our calculus is based on Eff, an existing calculus for algebraic effects, extended with Koka-style row polymorphism, and consists of a formal grammar, operational semantics, a (type-safe) type-and-effect system and type inference. We demonstrate \${\textbackslash}lambda\_\{{\textbackslash}mathit\{sc\}\}\$ on a range of examples.},
	urldate = {2023-10-19},
	publisher = {arXiv},
	author = {Bosman, Roger and van den Berg, Birthe and Tang, Wenhao and Schrijvers, Tom},
	month = apr,
	year = {2023},
	note = {arXiv:2304.09697 [cs]},
	keywords = {Computer Science - Programming Languages},
}

@article{kidney_algebras_2021,
	title = {Algebras for weighted search},
	issn = {2475-1421},
	url = {http://hdl.handle.net/10044/1/90693},
	doi = {10.1145/3473577},
	abstract = {Weighted search is an essential component of many fundamental and useful algorithms. Despite this, it is relatively under explored as a computational effect, receiving not nearly as much attention as either depth- or breadth-first search. This paper explores the algebraic underpinning of weighted search, and demonstrates how to implement it as a monad transformer. The development first explores breadth-first search, which can be expressed as a polynomial over semirings. These polynomials are generalised to the free semi module monad to capture a wide range of applications, including probability monads, polynomial monads, and monads for weighted search. Finally, a monad trans-former based on the free semi module monad is introduced. Applying optimisations to this type yields an implementation of pairing heaps, which is then used to implement Dijkstra’s algorithm and efficient probabilistic sampling. The construction is formalised in Cubical Agda and implemented in Haskell.},
	language = {eng},
	urldate = {2023-01-31},
	author = {Kidney, Donnacha Oisín and Wu, Nicolas},
	year = {2021},
	note = {Publisher: Association for Computing Machinery ACM},
	keywords = {Agda, BACKTRACKING, Computer Science, Computer Science, Software Engineering, Haskell, MONAD TRANSFORMERS, Science \& Technology, Technology, graph search, monad},
}

@inproceedings{jones_probabilistic_1989,
	title = {A probabilistic powerdomain of evaluations},
	url = {https://ieeexplore.ieee.org/document/39173},
	doi = {10.1109/LICS.1989.39173},
	abstract = {A probabilistic power domain construction is given for the category of inductively complete partial orders. It is the partial order of continuous},
	urldate = {2023-10-13},
	booktitle = {[1989] {Proceedings}. {Fourth} {Annual} {Symposium} on {Logic} in {Computer} {Science}},
	author = {Jones, Claire and Plotkin, Gordon D.},
	month = jun,
	year = {1989},
	pages = {186--195},
}

@article{plotkin_powerdomain_1976,
	title = {A {Powerdomain} {Construction}},
	volume = {5},
	issn = {0097-5397},
	doi = {10.1137/0205035},
	abstract = {We develop a powerdomain construction, \${\textbackslash}mathcal\{P\}[ {\textbackslash}cdot ]\$, which is analogous to the powerset construction and also fits in with the usual sum, product and exponentiation constructions on domains. The desire for such a construction arises when considering programming languages with nondeterministic features or parallel features treated in a nondeterministic way. We hope to achieve a natural, fully abstract semantics in which such equivalences as \$(p{\textbackslash}textit\{ par \} p) = (q{\textbackslash}textit\{ par \}p)\$ hold. The domain (\$D {\textbackslash}to \$ Truthvalues) is not the right one, and instead we take the (finitely) generable subsets of \$D\$. When \$D\$ is discrete they are ordered in an elementwise fashion. In the general case they are given the coarsest ordering consistent, in an appropriate sense, with the ordering given in the discrete case. We then find a restricted class of algebraic inductive partial orders which is closed under \${\textbackslash}mathcal\{P\}[ {\textbackslash}cdot ]\$ as well as the sum, product and exponentiation constructions. This class permits the solution of recursive domain equations, and we give some illustrative semantics using \${\textbackslash}mathcal\{P\}[ {\textbackslash}cdot ]\$. It remains to be seen if our powerdomain construction does give rise to fully abstract semantics, although such natural equivalences as the above do hold. The major deficiency is the lack of a convincing treatment of the fair parallel construct.},
	language = {eng},
	number = {3},
	journal = {SIAM journal on computing},
	author = {Plotkin, Gordon D.},
	year = {1976},
	note = {Place: Philadelphia
Publisher: Society for Industrial and Applied Mathematics},
	keywords = {Construction, Initial public offerings, Programming languages, Semantics},
	pages = {452--487},
}

@unpublished{arkor_higher-order_2020,
	type = {Draft paper},
	title = {Higher-order algebraic theories},
	url = {https://arkor.co/files/Higher-order%20algebraic%20theories.pdf},
	abstract = {Algebraic theories give a presentation-free categorical formulation of universal algebraic structure: objects equipped with first-order operators, subject to equational laws. Similarly, higher-order algebraic theories describe objects equipped with higher-order, variable-binding operators, such as logical quantifiers or λabstraction. While higher-order structures abound in mathematics and computer science, there exists no systematic treatment in the spirit of that for first-order structure. This has led to a proliferation of variations of higher-order theory, and consequently a lacklustre general understanding. We take the first steps to rectify this, defining a notion of multisorted higher-order algebraic theory and carrying out a development analogous to that of the first-order setting. In addition to unifying various previous notions, we (1) establish a correspondence between higher-order algebraic theories and a class of (relative) monads, whose algebras describe the closed-term structure of the corresponding theories; (2) prove that the categories of higher-order algebraic theories, and of the term algebras for a higher-order algebraic theory, are locally strongly finitely presentable; (3) give a new explanation for the apparent asymmetry between models of algebraic theories in the category of sets, and models in arbitrary cartesian categories.},
	urldate = {2023-11-08},
	author = {Arkor, Nathanael and McDermott, Dylan},
	year = {2020},
}

@article{stark_free-algebra_2008,
	title = {Free-algebra models for the pi-calculus},
	volume = {390},
	issn = {0304-3975},
	doi = {10.1016/j.tcs.2007.09.024},
	language = {eng},
	number = {2},
	journal = {Theoretical computer science},
	author = {Stark, Ian},
	year = {2008},
	note = {Place: Amsterdam
Publisher: Elsevier B.V},
	keywords = {Algebra, Applied sciences, Category theory, homological algebra, Combinatorics, Combinatorics. Ordered structures, Computational monads, Computer science; control theory; systems, Concurrency, Denotational semantics, Designs and configurations, Exact sciences and technology, Lawvere theories, Mathematics, Miscellaneous, Nominal sets, Nonassociative rings and algebras, Sciences and techniques of general use, Theoretical computing},
	pages = {248--270},
}

@inproceedings{wu_effect_2014,
	address = {New York, NY, USA},
	series = {Haskell '14},
	title = {Effect handlers in scope},
	isbn = {978-1-4503-3041-1},
	url = {https://dl.acm.org/doi/10.1145/2633357.2633358},
	doi = {10.1145/2633357.2633358},
	abstract = {Algebraic effect handlers are a powerful means for describing effectful computations. They provide a lightweight and orthogonal technique to define and compose the syntax and semantics of different effects. The semantics is captured by handlers, which are functions that transform syntax trees. Unfortunately, the approach does not support syntax for scoping constructs, which arise in a number of scenarios. While handlers can be used to provide a limited form of scope, we demonstrate that this approach constrains the possible interactions of effects and rules out some desired semantics. This paper presents two different ways to capture scoped constructs in syntax, and shows how to achieve different semantics by reordering handlers. The first approach expresses scopes using the existing algebraic handlers framework, but has some limitations. The problem is fully solved in the second approach where we introduce higher-order syntax.},
	urldate = {2023-11-20},
	booktitle = {Proceedings of the 2014 {ACM} {SIGPLAN} symposium on {Haskell}},
	publisher = {Association for Computing Machinery},
	author = {Wu, Nicolas and Schrijvers, Tom and Hinze, Ralf},
	month = sep,
	year = {2014},
	keywords = {Haskell, effect handlers, modularity, monads, semantics, syntax},
	pages = {1--12},
}

@book{scott_outline_1970,
	address = {Oxford},
	series = {Technical monograph ; {PRG}},
	title = {Outline of a mathematical theory of computation},
	language = {eng},
	number = {2},
	publisher = {Oxford University Computing Laboratory, Programming Research Group},
	author = {Scott, Dana S.},
	year = {1970},
	keywords = {Numerical calculations},
}

@book{scott_toward_1971,
	address = {Oxford},
	series = {Technical monograph ; {PRG}},
	title = {Toward a mathematical semantics for computer languages},
	isbn = {978-0-902928-03-9},
	language = {eng},
	number = {6},
	publisher = {Oxford University Computing Laboratory, Programming Research Group},
	author = {Scott, Dana S.},
	collaborator = {Strachey, Christopher},
	year = {1971},
	keywords = {Computer programming, Programming languages (Electronic computers)},
}

@inproceedings{pauwels_handling_2019,
	address = {Cham},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Handling {Local} {State} with {Global} {State}},
	isbn = {978-3-030-33636-3},
	doi = {10.1007/978-3-030-33636-3_2},
	abstract = {Equational reasoning is one of the most important tools of functional programming. To facilitate its application to monadic programs, Gibbons and Hinze have proposed a simple axiomatic approach using laws that characterise the computational effects without exposing their implementation details. At the same time Plotkin and Pretnar have proposed algebraic effects and handlers, a mechanism of layered abstractions by which effects can be implemented in terms of other effects.},
	language = {en},
	booktitle = {Mathematics of {Program} {Construction}},
	publisher = {Springer International Publishing},
	author = {Pauwels, Koen and Schrijvers, Tom and Mu, Shin-Cheng},
	editor = {Hutton, Graham},
	year = {2019},
	keywords = {Contextual equivalence, Effect handlers, Equational reasoning, Monads, Nondeterminism, State},
	pages = {18--44},
}

@book{manes_algebraic_1976,
	address = {New York},
	series = {Graduate texts in mathematics},
	title = {Algebraic theories},
	isbn = {978-0-387-90140-4},
	language = {eng},
	number = {26},
	publisher = {Springer-Verlag},
	author = {Manes, Ernest G.},
	year = {1976},
	keywords = {Algebra, Universal, Categories (Mathematics)},
}

@misc{gill_controlmonadwriterclass_2001,
	address = {Hackage},
	title = {Control.{Monad}.{Writer}.{Class}},
	url = {https://hackage.haskell.org/package/mtl-2.3.1/docs/Control-Monad-Writer-Class.html},
	abstract = {The MonadWriter class.},
	author = {Gill, Andy},
	year = {2001},
}

@book{godement_topologie_1958,
	address = {Paris},
	series = {Actualités scientifiques et industrielles},
	title = {Topologie algébrique et théorie des faisceaux.},
	language = {fre},
	number = {1252},
	publisher = {Hermann},
	author = {Godement, Roger},
	year = {1958},
	keywords = {Algebraic topology},
}

@phdthesis{arkor_monadic_2022,
	title = {Monadic and {Higher}-{Order} {Structure}},
	url = {https://www.repository.cam.ac.uk/handle/1810/338940},
	abstract = {Simple type theories, ubiquitous in the study of programming language theory, augment algebraic theories with higher-order, variable-binding structure. This motivates the definition of higher-order algebraic theories to capture this structure, permitting the study of simple type theories in a categorical setting analogous to that of algebraic theories. The theory of higher-order algebraic theories is in one sense much richer than that of algebraic theories, as we may stratify the former according to their order: for instance, the first-order algebraic theories are precisely the classical algebraic theories, the second-order algebraic theories permit operators to abstract over operators, the third-order algebraic theories permit operators to abstract over operators that themselves abstract over operators, and so on. We study the structure of the category of (n + 1)th-order algebraic theories, demonstrating that it may be viewed as a construction on the category of nth-order algebraic theories, facilitating an inductive construction of the category of higher-order algebraic theories. In turn, this description leads naturally to a monad–theory correspondence for higher-order algebraic theories, subsuming the classical monad–theory correspondence, and providing a new, monadic understanding of higher-order structure.
In proving the monad–theory correspondence for higher-order algebraic theories, we are led to reconsider the traditional perspective on the classical monad–theory correspondence. In doing so, we reveal a new understanding of the relationship between algebraic theories and monads that clarifies the nature of the correspondence. The crucial insight follows from the consideration of relative monads, which are shown to act as an intermediary in the correspondence. To support our proposal that this be viewed as the correct perspective of the monad–theory correspondence, we show how the same proof may be carried out in a formal 2-categorical setting. The classical monad–theory correspondence, as well as those in the literature for enriched and internal categories, then follow as corollaries of a general theory.
Sansom Premium Scholarship},
	language = {eng},
	urldate = {2023-11-08},
	school = {University of Cambridge},
	author = {Arkor, Nathanael},
	year = {2022},
	doi = {10.17863/CAM.86347},
	keywords = {2-categories, algebraic theories, category theory, monads, relative monads, type theory},
}

@article{staton_algebraic_2015,
	title = {Algebraic {Effects}, {Linearity}, and {Quantum} {Programming} {Languages}},
	volume = {50},
	issn = {0362-1340},
	url = {https://dl.acm.org/doi/10.1145/2775051.2676999},
	doi = {10.1145/2775051.2676999},
	abstract = {We develop a new framework of algebraic theories with linear parameters, and use it to analyze the equational reasoning principles of quantum computing and quantum programming languages. We use the framework as follows: we present a new elementary algebraic theory of quantum computation, built from unitary gates and measurement; we provide a completeness theorem or the elementary algebraic theory by relating it with a model from operator algebra; we extract an equational theory for a quantum programming language from the algebraic theory; we compare quantum computation with other local notions of computation by investigating variations on the algebraic theory.},
	number = {1},
	urldate = {2023-11-20},
	journal = {ACM SIGPLAN Notices},
	author = {Staton, Sam},
	month = jan,
	year = {2015},
	keywords = {algebraic effects, monads., quantum computation},
	pages = {395--406},
}

@inproceedings{dolan_concurrent_2018,
	address = {Cham},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Concurrent {System} {Programming} with {Effect} {Handlers}},
	isbn = {978-3-319-89719-6},
	doi = {10.1007/978-3-319-89719-6_6},
	abstract = {Algebraic effects and their handlers have been steadily gaining attention as a programming language feature for composably expressing user-defined computational effects. While several prototype implementations of languages incorporating algebraic effects exist, Multicore OCaml incorporates effect handlers as the primary means of expressing concurrency in the language. In this paper, we make the observation that effect handlers can elegantly express particularly difficult programs that combine system programming and concurrency without compromising performance. Our experimental results on a highly concurrent and scalable web server demonstrate that effect handlers perform on par with highly optimised monadic concurrency libraries, while retaining the simplicity of direct-style code.},
	language = {en},
	booktitle = {Trends in {Functional} {Programming}},
	publisher = {Springer International Publishing},
	author = {Dolan, Stephen and Eliopoulos, Spiros and Hillerström, Daniel and Madhavapeddy, Anil and Sivaramakrishnan, K. C. and White, Leo},
	editor = {Wang, Meng and Owens, Scott},
	year = {2018},
	keywords = {Algebraic Effects, Default Handler, Event Handler, Programming Concurrent Systems, User-level Threads},
	pages = {98--117},
}

@inproceedings{hartmann_algorithm_2022,
	address = {Cham},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Algorithm {Design} with the {Selection} {Monad}},
	isbn = {978-3-031-21314-4},
	shorttitle = {{TFP}},
	doi = {10.1007/978-3-031-21314-4_7},
	abstract = {The selection monad has proven useful for modelling exhaustive search algorithms. It is well studied in the area of game theory as an elegant way of expressing algorithms that calculate optimal plays for sequential games with perfect information; composition of moves is modeled as a ‘product’ of selection functions. This paper aims to expand the application of the selection monad to other classes of algorithms. The structure used to describe exhaustive search problems can easily be applied to greedy algorithms; with some changes to the product function, the behaviour of the selection monad can be changed from an exhaustive search behaviour to a greedy one. This enables an algorithm design framework in which the behaviour of the algorithm can be exchanged modularly by using different product functions.},
	language = {en},
	booktitle = {Trends in {Functional} {Programming}},
	publisher = {Springer International Publishing},
	author = {Hartmann, Johannes and Gibbons, Jeremy},
	editor = {Swierstra, Wouter and Wu, Nicolas},
	year = {2022},
	keywords = {Algorithm design, Functional programming, Greedy algorithms, Monads, Selection monad},
	pages = {126--143},
}

@article{pitts_structural_2011,
	title = {Structural recursion with locally scoped names},
	volume = {21},
	issn = {0956-7968},
	doi = {10.1017/S0956796811000116},
	abstract = {This paper introduces a new recursion principle for inductively defined data modulo α-equivalence of bound names that makes use of Odersky-style local names when recursing over bound names. It is formulated in simply typed λ-calculus extended with names that can be restricted to a lexical scope, tested for equality, explicitly swapped and abstracted. The new recursion principle is motivated by the nominal sets notion of ‘α-structural recursion’, whose use of names and associated freshness side-conditions in recursive definitions formalizes common practice with binders. The new calculus has a simple interpretation in nominal sets equipped with name-restriction operations. It is shown to adequately represent α-structural recursion while avoiding the need to verify freshness side-conditions in definitions and computations. The paper is a revised and expanded version of Pitts (Nominal System T. In Proceedings of the 37th ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages, POPL 2010 (Madrid, Spain). ACM Press, pp. 159–170, 2010).},
	language = {eng},
	number = {3},
	journal = {Journal of functional programming},
	author = {Pitts, Andrew M.},
	year = {2011},
	note = {Place: Cambridge, UK
Publisher: Cambridge University Press},
	keywords = {Calculus, Freshness, Mathematical analysis, Names, Presses, Programming, Recursion, Recursive},
	pages = {235--286},
}

@article{kammar_handlers_2013,
	title = {Handlers in action},
	volume = {48},
	issn = {0362-1340},
	url = {https://dl.acm.org/doi/10.1145/2544174.2500590},
	doi = {10.1145/2544174.2500590},
	abstract = {Plotkin and Pretnar's handlers for algebraic effects occupy a sweet spot in the design space of abstractions for effectful computation. By separating effect signatures from their implementation, algebraic effects provide a high degree of modularity, allowing programmers to express effectful programs independently of the concrete interpretation of their effects. A handler is an interpretation of the effects of an algebraic computation. The handler abstraction adapts well to multiple settings: pure or impure, strict or lazy, static types or dynamic types. This is a position paper whose main aim is to popularise the handler abstraction. We give a gentle introduction to its use, a collection of illustrative examples, and a straightforward operational semantics. We describe our Haskell implementation of handlers in detail, outline the ideas behind our OCaml, SML, and Racket implementations, and present experimental results comparing handlers with existing code.},
	number = {9},
	urldate = {2023-11-10},
	journal = {ACM SIGPLAN Notices},
	author = {Kammar, Ohad and Lindley, Sam and Oury, Nicolas},
	month = sep,
	year = {2013},
	keywords = {algebraic effects, continuations, effect handlers, effect typing, haskell, modularity, monads},
	pages = {145--158},
}

@inproceedings{kura_graded_2020,
	address = {Cham},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Graded {Algebraic} {Theories}},
	isbn = {978-3-030-45231-5},
	doi = {10.1007/978-3-030-45231-5_21},
	abstract = {We provide graded extensions of algebraic theories and Lawvere theories that correspond to graded monads. We prove that graded algebraic theories, graded Lawvere theories, and finitary graded monads are equivalent via equivalence of categories, which extends the equivalence for monads. We also give sums and tensor products of graded algebraic theories to combine computational effects as an example of importing techniques based on algebraic theories to graded monads.},
	language = {en},
	booktitle = {Foundations of {Software} {Science} and {Computation} {Structures}},
	publisher = {Springer International Publishing},
	author = {Kura, Satoshi},
	editor = {Goubault-Larrecq, Jean and König, Barbara},
	year = {2020},
	pages = {401--421},
}

@article{katsumata_flexible_2022,
	title = {Flexible presentations of graded monads},
	volume = {6},
	issn = {2475-1421},
	doi = {10.1145/3547654},
	abstract = {A large class of monads used to model computational effects have natural presentations by operations and equations, for example, the list monad can be presented by a constant and a binary operation subject to unitality and associativity. Graded monads are a generalization of monads that enable us to track quantitative information about the effects being modelled. Correspondingly, a large class of graded monads can be presented using an existing notion of graded presentation. However, the existing notion has some deficiencies, in particular many effects do not have natural graded presentations. We introduce a notion of flexibly graded presentation that does not suffer from these issues, and develop the associated theory. We show that every flexibly graded presentation induces a graded monad equipped with interpretations of the operations of the presentation, and that all graded monads satisfying a particular condition on colimits have a flexibly graded presentation. As part of this, we show that the usual algebra-preserving correspondence between presentations and a class of monads transfers to an algebra-preserving correspondence between flexibly graded presentations and a class of flexibly graded monads.},
	language = {eng},
	number = {ICFP},
	journal = {Proceedings of ACM on programming languages},
	author = {Katsumata, Shin-ya and McDermott, Dylan and Uustalu, Tarmo and Wu, Nicolas},
	year = {2022},
	note = {Publisher: Association for Computing Machinery},
	pages = {902--930},
}

@misc{fiore_functorial_2014,
	title = {Functorial {Semantics} of {Second}-{Order} {Algebraic} {Theories}},
	url = {http://arxiv.org/abs/1401.4697},
	doi = {10.48550/arXiv.1401.4697},
	abstract = {The purpose of this work is to complete the algebraic foundations of second-order languages from the viewpoint of categorical algebra as developed by Lawvere. To this end, this paper introduces the notion of second-order algebraic theory and develops its basic theory. A crucial role in the definition is played by the second-order theory of equality \${\textbackslash}M\$, representing the most elementary operators and equations present in every second-order language. The category \${\textbackslash}M\$ can be described abstractly via the universal property of being the free cartesian category on an exponentiable object. Thereby, in the tradition of categorical algebra, a second-order algebraic theory consists of a cartesian category \${\textbackslash}Mlaw\$ and a strict cartesian identity-on-objects functor \${\textbackslash}M {\textbackslash}to {\textbackslash}Mlaw\$ that preserves the universal exponentiable object of \${\textbackslash}Mlaw\$. Lawvere's functorial semantics for algebraic theories can then be generalised to the second-order setting. To verify the correctness of our theory, two categorical equivalences are established: at the syntactic level, that of second-order equational presentations and second-order algebraic theories; at the semantic level, that of second-order algebras and second-order functorial models.},
	urldate = {2023-11-08},
	publisher = {arXiv},
	author = {Fiore, Marcelo and Mahmoud, Ola},
	month = jan,
	year = {2014},
	note = {arXiv:1401.4697 [cs, math]
version: 1},
	keywords = {Computer Science - Logic in Computer Science, Mathematics - Category Theory},
}

@book{kelly_basic_1982,
	address = {Cambridge},
	series = {London {Mathematical} {Society} lecture note series},
	title = {Basic concepts of enriched category theory},
	isbn = {978-0-521-28702-9},
	language = {eng},
	number = {64},
	publisher = {University Press},
	author = {Kelly, G. M.},
	year = {1982},
	keywords = {Categories (Mathematics)},
}

@article{barr_toposes_2005,
	title = {Toposes, {Triples} and {Theories}},
	volume = {12},
	issn = {1201-561X},
	language = {eng},
	journal = {Theory and applications of categories},
	author = {Barr, Michael and Wells, Charles},
	year = {2005},
	note = {Place: Sackville
Publisher: R. Rosebrugh},
	keywords = {Category theory},
	pages = {1--},
}

@inproceedings{leijen_structured_2017,
	address = {New York, NY, USA},
	series = {{TyDe} 2017},
	title = {Structured asynchrony with algebraic effects},
	isbn = {978-1-4503-5183-6},
	url = {https://dl.acm.org/doi/10.1145/3122975.3122977},
	doi = {10.1145/3122975.3122977},
	abstract = {Algebraic effect handlers generalize many control-flow abstractions that are implemented specially in most languages, like exception handling, iterators, or backtracking. In this article, we show how we can implement full support for asynchronous programming as a library using just algebraic effect handlers. The consistent type driven approach also leads naturally to powerful abstractions like block-scoped interleaving, cancellation, and timeout's that are lacking in other major asynchronous frameworks. We also introduce the concept of ambient state to reason about state that is local to the current strand of asynchronous execution.},
	urldate = {2023-11-01},
	booktitle = {Proceedings of the 2nd {ACM} {SIGPLAN} {International} {Workshop} on {Type}-{Driven} {Development}},
	publisher = {Association for Computing Machinery},
	author = {Leijen, Daan},
	month = sep,
	year = {2017},
	keywords = {Algebraic effects, Koka, asynchronous programming, effect types},
	pages = {16--29},
}

@inproceedings{peyton_jones_concurrent_1996,
	address = {New York, NY, USA},
	series = {{POPL} '96},
	title = {Concurrent {Haskell}},
	isbn = {978-0-89791-769-8},
	url = {https://doi.org/10.1145/237721.237794},
	doi = {10.1145/237721.237794},
	urldate = {2023-11-01},
	booktitle = {Proceedings of the 23rd {ACM} {SIGPLAN}-{SIGACT} symposium on {Principles} of programming languages},
	publisher = {Association for Computing Machinery},
	author = {Peyton Jones, Simon and Gordon, Andrew and Finne, Sigbjorn},
	month = jan,
	year = {1996},
	pages = {295--308},
}

@article{paszke_getting_2021,
	title = {Getting to the point: index sets and parallelism-preserving autodiff for pointful array programming},
	volume = {5},
	shorttitle = {Getting to the point},
	url = {https://dl.acm.org/doi/10.1145/3473593},
	doi = {10.1145/3473593},
	abstract = {We present a novel programming language design that attempts to combine the clarity and safety of high-level functional languages with the efficiency and parallelism of low-level numerical languages. We treat arrays as eagerly-memoized functions on typed index sets, allowing abstract function manipulations, such as currying, to work on arrays. In contrast to composing primitive bulk-array operations, we argue for an explicit nested indexing style that mirrors application of functions to arguments. We also introduce a fine-grained typed effects system which affords concise and automatically-parallelized in-place updates. Specifically, an associative accumulation effect allows reverse-mode automatic differentiation of in-place updates in a way that preserves parallelism. Empirically, we benchmark against the Futhark array programming language, and demonstrate that aggressive inlining and type-driven compilation allows array programs to be written in an expressive, "pointful" style with little performance penalty.},
	number = {ICFP},
	urldate = {2023-11-01},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Paszke, Adam and Johnson, Daniel D. and Duvenaud, David and Vytiniotis, Dimitrios and Radul, Alexey and Johnson, Matthew J. and Ragan-Kelley, Jonathan and Maclaurin, Dougal},
	month = aug,
	year = {2021},
	keywords = {Array programming, automatic differentiation, parallel computing},
	pages = {88:1--88:29},
}

@inproceedings{cooper_links_2007,
	address = {Berlin, Heidelberg},
	title = {Links: {Web} {Programming} {Without} {Tiers}},
	isbn = {978-3-540-74791-8},
	shorttitle = {Links},
	doi = {10.1007/978-3-540-74792-5_12},
	abstract = {Links is a programming language for web applications that generates code for all three tiers of a web application from a single source, compiling into JavaScript to run on the client and into SQL to run on the database. Links supports rich clients running in what has been dubbed ‘Ajax’ style, and supports concurrent processes with statically-typed message passing. Links is scalable in the sense that session state is preserved in the client rather than the server, in contrast to other approaches such as Java Servlets or PLT Scheme. Client-side concurrency in JavaScript and transfer of computation between client and server are both supported by translation into continuation-passing style.},
	language = {eng},
	publisher = {Springer Berlin Heidelberg},
	author = {Cooper, Ezra and Lindley, Sam and Wadler, Philip and Yallop, Jeremy},
	year = {2007},
	note = {Book Title: Formal Methods for Components and Objects
ISSN: 0302-9743},
	keywords = {Event Handler, Input Element, Message Passing, Regular Expression, Session State},
	pages = {266--296},
}

@inproceedings{lindley_row-based_2012,
	address = {New York, NY, USA},
	series = {{TLDI} '12},
	title = {Row-based effect types for database integration},
	isbn = {978-1-4503-1120-5},
	url = {https://dl.acm.org/doi/10.1145/2103786.2103798},
	doi = {10.1145/2103786.2103798},
	abstract = {We present CoreLinks, a call-by-value variant of System F with row polymorphism, row-based effect types, and implicit subkinding, which forms the basis for the Links web programming language. We focus on extensions to CoreLinks for database programming. The effect types support abstraction over database queries, while ensuring that queries are translated predictably to idiomatic and efficient SQL at run-time. Subkinding statically enforces the constraint that queries must return a list of records of base type. Polymorphism over the presence of record labels supports abstraction over database queries, inserts, deletes and updates.},
	urldate = {2023-11-01},
	booktitle = {Proceedings of the 8th {ACM} {SIGPLAN} workshop on {Types} in language design and implementation},
	publisher = {Association for Computing Machinery},
	author = {Lindley, Sam and Cheney, James},
	month = jan,
	year = {2012},
	keywords = {effect types, language integrated query, normalisation, polymorphism, row types},
	pages = {91--102},
}

@inproceedings{lindley_be_2017,
	address = {New York, NY, USA},
	series = {{POPL} '17},
	title = {Do be do be do},
	isbn = {978-1-4503-4660-3},
	url = {https://dl.acm.org/doi/10.1145/3009837.3009897},
	doi = {10.1145/3009837.3009897},
	abstract = {We explore the design and implementation of Frank, a strict functional programming language with a bidirectional effect type system designed from the ground up around a novel variant of Plotkin and Pretnar's effect handler abstraction. Effect handlers provide an abstraction for modular effectful programming: a handler acts as an interpreter for a collection of commands whose interfaces are statically tracked by the type system. However, Frank eliminates the need for an additional effect handling construct by generalising the basic mechanism of functional abstraction itself. A function is simply the special case of a Frank operator that interprets no commands. Moreover, Frank's operators can be multihandlers which simultaneously interpret commands from several sources at once, without disturbing the direct style of functional programming with values. Effect typing in Frank employs a novel form of effect polymorphism which avoid mentioning effect variables in source code. This is achieved by propagating an ambient ability inwards, rather than accumulating unions of potential effects outwards. We introduce Frank by example, and then give a formal account of the Frank type system and its semantics. We introduce Core Frank by elaborating Frank operators into functions, case expressions, and unary handlers, and then give a sound small-step operational semantics for Core Frank. Programming with effects and handlers is in its infancy. We contribute an exploration of future possibilities, particularly in combination with other forms of rich type system.},
	urldate = {2023-11-01},
	booktitle = {Proceedings of the 44th {ACM} {SIGPLAN} {Symposium} on {Principles} of {Programming} {Languages}},
	publisher = {Association for Computing Machinery},
	author = {Lindley, Sam and McBride, Conor and McLaughlin, Craig},
	month = jan,
	year = {2017},
	keywords = {algebraic effects, bidirectional typing, call-by-push-value, continuations, effect handlers, effect polymorphism, pattern matching},
	pages = {500--514},
}

@article{bauer_programming_2015,
	series = {Special {Issue}: {The} 23rd {Nordic} {Workshop} on {Programming} {Theory} ({NWPT} 2011)},
	title = {Programming with algebraic effects and handlers},
	volume = {84},
	issn = {2352-2208},
	url = {https://www.sciencedirect.com/science/article/pii/S2352220814000194},
	doi = {10.1016/j.jlamp.2014.02.001},
	abstract = {Eff is a programming language based on the algebraic approach to computational effects, in which effects are viewed as algebraic operations and effect handlers as homomorphisms from free algebras. Eff supports first-class effects and handlers through which we may easily define new computational effects, seamlessly combine existing ones, and handle them in novel ways. We give a denotational semantics of Eff and discuss a prototype implementation based on it. Through examples we demonstrate how the standard effects are treated in Eff, and how Eff supports programming techniques that use various forms of delimited continuations, such as backtracking, breadth-first search, selection functionals, cooperative multi-threading, and others.},
	number = {1},
	urldate = {2023-11-01},
	journal = {Journal of Logical and Algebraic Methods in Programming},
	author = {Bauer, Andrej and Pretnar, Matija},
	month = jan,
	year = {2015},
	pages = {108--123},
}

@article{leijen_koka_2014,
	title = {Koka: {Programming} with {Row} {Polymorphic} {Effect} {Types}},
	volume = {153},
	issn = {2075-2180},
	shorttitle = {Koka},
	doi = {10.4204/EPTCS.153.8},
	abstract = {We propose a programming model where effects are treated in a disciplined way, and where the potential side-effects of a function are apparent in its type signature. The type and effect of expressions can also be inferred automatically, and we describe a polymorphic type inference system based on Hindley-Milner style inference. A novel feature is that we support polymorphic effects through row-polymorphism using duplicate labels. Moreover, we show that our effects are not just syntactic labels but have a deep semantic connection to the program. For example, if an expression can be typed without an exn effect, then it will never throw an unhandled exception. Similar to Haskell's `runST` we show how we can safely encapsulate stateful operations. Through the state effect, we can also safely combine state with let-polymorphism without needing either imperative type variables or a syntactic value restriction. Finally, our system is implemented fully in a new language called Koka and has been used successfully on various small to medium-sized sample programs ranging from a Markdown processor to a tier-splitted chat application. You can try out Koka live at www.rise4fun.com/koka/tutorial.},
	language = {eng},
	number = {Proc. MSFP 2014},
	journal = {Electronic proceedings in theoretical computer science},
	author = {Leijen, Daan},
	year = {2014},
	note = {Place: Ithaca
Publisher: Cornell University Library, arXiv.org},
	keywords = {Computer Science - Programming Languages, Inference, Labels, Microprocessors, Polymorphism},
	pages = {100--126},
}

@article{ahman_asynchronous_2021,
	title = {Asynchronous effects},
	volume = {5},
	url = {https://dl.acm.org/doi/10.1145/3434305},
	doi = {10.1145/3434305},
	abstract = {We explore asynchronous programming with algebraic effects. We complement their conventional synchronous treatment by showing how to naturally also accommodate asynchrony within them, namely, by decoupling the execution of operation calls into signalling that an operation’s implementation needs to be executed, and interrupting a running computation with the operation’s result, to which the computation can react by installing interrupt handlers. We formalise these ideas in a small core calculus, called λæ. We demonstrate the flexibility of λæ using examples ranging from a multi-party web application, to preemptive multi-threading, to remote function calls, to a parallel variant of runners of algebraic effects. In addition, the paper is accompanied by a formalisation of λæ’s type safety proofs in Agda, and a prototype implementation of λæ in OCaml.},
	number = {POPL},
	urldate = {2023-10-31},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Ahman, Danel and Pretnar, Matija},
	month = jan,
	year = {2021},
	keywords = {algebraic effects, asynchrony, concurrency, interrupt handling, signals},
	pages = {24:1--24:28},
}

@inproceedings{staton_instances_2013,
	address = {USA},
	series = {{LICS} '13},
	title = {Instances of {Computational} {Effects}: {An} {Algebraic} {Perspective}},
	isbn = {978-0-7695-5020-6},
	shorttitle = {Instances of {Computational} {Effects}},
	abstract = {We investigate the connections between computational effects, algebraic theories, and monads on functor categories. We develop a syntactic framework with variable binding that allows us to describe equations between programs while taking into account the idea that there may be different instances of a particular computational effect. We use our framework to give a general account of several notions of computation that had previously been analyzed in terms of monads on presheaf categories: the analysis of local store by Plotkin and Power; the analysis of restriction by Pitts; and the analysis of the pi calculus by Stark.},
	urldate = {2023-10-31},
	booktitle = {Proceedings of the 2013 28th {Annual} {ACM}/{IEEE} {Symposium} on {Logic} in {Computer} {Science}},
	publisher = {IEEE Computer Society},
	author = {Staton, Sam},
	month = jun,
	year = {2013},
	pages = {519},
}

@article{marlow_asynchronous_2001,
	title = {Asynchronous exceptions in {Haskell}},
	volume = {36},
	issn = {0362-1340},
	url = {https://dl.acm.org/doi/10.1145/381694.378858},
	doi = {10.1145/381694.378858},
	abstract = {Asynchronous exceptions, such as timeouts are important for robust, modular programs, but are extremely difficult to program with — so much so that most programming languages either heavily restrict them or ban them altogether. We extend our earlier work, in which we added synchronous exceptions to Haskell, to support asynchronous exceptions too. Our design introduces scoped combinators for blocking and unblocking asynchronous interrupts, along with a somewhat surprising semantics for operations that can suspend. Uniquely, we also give a formal semantics for our system.},
	number = {5},
	urldate = {2023-10-31},
	journal = {ACM SIGPLAN Notices},
	author = {Marlow, Simon and Jones, Simon Peyton and Moran, Andrew and Reppy, John},
	month = may,
	year = {2001},
	pages = {274--285},
}

@inproceedings{van_den_berg_latent_2021,
	address = {Cham},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Latent {Effects} for {Reusable} {Language} {Components}},
	isbn = {978-3-030-89051-3},
	doi = {10.1007/978-3-030-89051-3_11},
	abstract = {The development of programming languages can be quite complicated and costly. Hence, much effort has been devoted to the modular definition of language features that can be reused in various combinations to define new languages and experiment with their semantics. A notable outcome of these efforts is the algebra-based “datatypes à la carte” (DTC) approach. When combined with algebraic effects, DTC can model a wide range of common language features. Unfortunately, the current state of the art does not cover modular definitions of advanced control-flow mechanisms that defer execution to an appropriate point, such as call-by-name and call-by-need evaluation, as well as (multi-)staging.},
	language = {en},
	booktitle = {Programming {Languages} and {Systems}},
	publisher = {Springer International Publishing},
	author = {van den Berg, Birthe and Schrijvers, Tom and Poulsen, Casper Bach and Wu, Nicolas},
	editor = {Oh, Hakjoo},
	year = {2021},
	keywords = {Effect handlers, Effects, Modularity, Monads, Staging},
	pages = {182--201},
}

@misc{xie_parallel_2021,
	title = {Parallel {Algebraic} {Effect} {Handlers}},
	url = {http://arxiv.org/abs/2110.07493},
	doi = {10.48550/arXiv.2110.07493},
	abstract = {Algebraic effects and handlers support composable and structured control-flow abstraction. However, existing designs of algebraic effects often require effects to be executed sequentially. This paper studies parallel algebraic effect handlers. In particular, we formalize \{{\textbackslash}lambda\}p, an untyped lambda calculus which models two key features, effect handlers and parallelizable computations, the latter of which takes the form of a for expression as inspired by the Dex programming language. We present various interesting examples expressible in our calculus, and provide a Haskell implementation. We hope this paper provides a basis for future designs and implementations of parallel algebraic effect handlers.},
	urldate = {2023-10-31},
	publisher = {arXiv},
	author = {Xie, Ningning and Johnson, Daniel D. and Maclaurin, Dougal and Paszke, Adam},
	month = oct,
	year = {2021},
	note = {arXiv:2110.07493 [cs]},
	keywords = {Computer Science - Programming Languages},
}

@inproceedings{frostig_compiling_2018,
	series = {9},
	title = {Compiling machine learning programs via high-level tracing},
	volume = {4},
	url = {https://mlsys.org/Conferences/doc/2018/146.pdf},
	abstract = {We describe JAX, a domain-specific tracing JIT compiler for generating high-performance accelerator code from pure Python and Numpy machine learning programs. JAX uses the XLA compiler infrastructure to generate optimized code for the program subroutines that are most favorable for acceleration, and these optimized subroutines can be called and orchestrated by arbitrary Python. Because the system is fully compatible with Autograd, it allows forward- and reverse-mode automatic differentiation of Python functions to arbitrary order. Because JAX supports structured control flow, it can generate code for sophisticated machine learning algorithms while maintaining high performance. We show that by combining JAX with Autograd and Numpy we get an easily programmable and highly performant ML system that targets CPUs, GPUs, and TPUs, capable of scaling to multi-core Cloud TPUs.},
	booktitle = {Systems for {Machine} {Learning}},
	author = {Frostig, Roy and Johnson, Matthew and Leary, Chris},
	year = {2018},
}

@article{elliott_parallel_2014,
	title = {The parallel system for integrating impact models and sectors ({pSIMS})},
	volume = {62},
	issn = {1364-8152},
	url = {https://www.sciencedirect.com/science/article/pii/S1364815214001121},
	doi = {10.1016/j.envsoft.2014.04.008},
	abstract = {We present a framework for massively parallel climate impact simulations: the parallel System for Integrating Impact Models and Sectors (pSIMS). This framework comprises a) tools for ingesting and converting large amounts of data to a versatile datatype based on a common geospatial grid; b) tools for translating this datatype into custom formats for site-based models; c) a scalable parallel framework for performing large ensemble simulations, using any one of a number of different impacts models, on clusters, supercomputers, distributed grids, or clouds; d) tools and data standards for reformatting outputs to common datatypes for analysis and visualization; and e) methodologies for aggregating these datatypes to arbitrary spatial scales such as administrative and environmental demarcations. By automating many time-consuming and error-prone aspects of large-scale climate impacts studies, pSIMS accelerates computational research, encourages model intercomparison, and enhances reproducibility of simulation results. We present the pSIMS design and use example assessments to demonstrate its multi-model, multi-scale, and multi-sector versatility.},
	urldate = {2023-10-30},
	journal = {Environmental Modelling \& Software},
	author = {Elliott, Joshua and Kelly, David and Chryssanthacopoulos, James and Glotter, Michael and Jhunjhnuwala, Kanika and Best, Neil and Wilde, Michael and Foster, Ian},
	month = dec,
	year = {2014},
	keywords = {Climate change impacts, adaptation, and vulnerabilities (VIA), Crop modeling, Data processing and standardization, Ensemble simulation, Forestry modeling, Multi-model, Parallel computing},
	pages = {509--516},
}

@misc{bradbury_jax_2018,
	title = {{JAX}: composable transformations of {Python}+{NumPy} programs},
	url = {http://github.com/google/jax},
	publisher = {Google},
	author = {Bradbury, James and Frostig, Roy and Hawkins, Peter and Johnson, Matthew James and Leary, Chris and Maclaurin, Dougal and Necula, George and Paszke, Adam and VanderPlas, Jake and Wanderman-Milne, Skye and Zhang, Qiao},
	year = {2018},
}

@inproceedings{fiore_second-order_2010,
	address = {Berlin, Heidelberg},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Second-{Order} {Algebraic} {Theories}},
	isbn = {978-3-642-15155-2},
	doi = {10.1007/978-3-642-15155-2_33},
	abstract = {Fiore and Hur [10] recently introduced a conservative extension of universal algebra and equational logic from first to second order. Second-order universal algebra and second-order equational logic respectively provide a model theory and a formal deductive system for languages with variable binding and parameterised metavariables. This work completes the foundations of the subject from the viewpoint of categorical algebra. Specifically, the paper introduces the notion of second-order algebraic theory and develops its basic theory. Two categorical equivalences are established: at the syntactic level, that of second-order equational presentations and second-order algebraic theories; at the semantic level, that of second-order algebras and second-order functorial models. Our development includes a mathematical definition of syntactic translation between second-order equational presentations. This gives the first formalisation of notions such as encodings and transforms in the context of languages with variable binding.},
	language = {en},
	booktitle = {Mathematical {Foundations} of {Computer} {Science} 2010},
	publisher = {Springer},
	author = {Fiore, Marcelo and Mahmoud, Ola},
	editor = {Hliněný, Petr and Kučera, Antonín},
	year = {2010},
	pages = {368--380},
}

@article{sangiorgi_communicating_2000,
	title = {Communicating and {Mobile} {Systems}: the pi-calculus},
	volume = {38},
	issn = {0167-6423},
	shorttitle = {Communicating and {Mobile} {Systems}},
	doi = {10.1016/S0167-6423(00)00008-3},
	language = {eng},
	number = {1-3},
	journal = {Science of computer programming},
	author = {Sangiorgi, Davide},
	year = {2000},
	pages = {151--153},
}

@misc{noauthor_neighborhood_2022,
	title = {A {Neighborhood} of {Infinity}: {The} {Antidiagonal}},
	shorttitle = {A {Neighborhood} of {Infinity}},
	url = {http://blog.sigfpe.com/2007/09/type-of-distinct-pairs.html},
	language = {en},
	urldate = {2022-11-25},
	year = {2022},
}

@misc{noauthor_neighborhood_2022-1,
	title = {A {Neighborhood} of {Infinity}: {Finite} {Differences} of {Types}},
	shorttitle = {A {Neighborhood} of {Infinity}},
	url = {http://blog.sigfpe.com/2009/09/finite-differences-of-types.html},
	language = {en},
	urldate = {2022-11-28},
	year = {2022},
}

@inproceedings{mellies_local_2014,
	address = {Cham},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Local {States} in {String} {Diagrams}},
	isbn = {978-3-319-08918-8},
	doi = {10.1007/978-3-319-08918-8_23},
	abstract = {We establish that the local state monad introduced by Plotkin and Power is a monad with graded arities in the category [Inj,Set]. From this, we deduce that the local state monad is associated to a graded Lawvere theory which is presented by generators and relations, depicted in the graphical language of string diagrams.},
	language = {en},
	booktitle = {Rewriting and {Typed} {Lambda} {Calculi}},
	publisher = {Springer International Publishing},
	author = {Melliès, Paul-André},
	editor = {Dowek, Gilles},
	year = {2014},
	pages = {334--348},
}

@incollection{staton_algebraic_2013,
	address = {Berlin, Heidelberg},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {An {Algebraic} {Presentation} of {Predicate} {Logic}: {Extended} {Abstract}},
	isbn = {978-3-642-37074-8},
	shorttitle = {An {Algebraic} {Presentation} of {Predicate} {Logic}},
	abstract = {We present an algebraic theory for a fragment of predicate logic. The fragment has disjunction, existential quantification and equality. It is not an algebraic theory in the classical sense, but rather within a new framework that we call ‘parameterized algebraic theories’.
We demonstrate the relevance of this algebraic presentation to computer science by identifying a programming language in which every type carries a model of the algebraic theory. The result is a simple functional logic programming language.
We provide a syntax-free representation theorem which places terms in bijection with sieves, a concept from category theory.
We study presentation-invariance for general parameterized algebraic theories by providing a theory of clones. We show that parameterized algebraic theories characterize a class of enriched monads.},
	language = {eng},
	booktitle = {Foundations of {Software} {Science} and {Computation} {Structures}},
	publisher = {Springer Berlin Heidelberg},
	author = {Staton, Sam},
	year = {2013},
	doi = {10.1007/978-3-642-37075-5_26},
	note = {ISSN: 0302-9743},
	keywords = {Algebraic Theory, Function Symbol, Logic Program, Logic Programming, Predicate Logic},
	pages = {401--417},
}

@article{power_semantics_2006,
	series = {Proceedings of the 22nd {Annual} {Conference} on {Mathematical} {Foundations} of {Programming} {Semantics} ({MFPS} {XXII})},
	title = {Semantics for {Local} {Computational} {Effects}},
	volume = {158},
	issn = {1571-0661},
	url = {https://www.sciencedirect.com/science/article/pii/S1571066106001721},
	doi = {10.1016/j.entcs.2006.04.018},
	abstract = {Starting with Moggi's work on monads as refined to Lawvere theories, we give a general construct that extends denotational semantics for a global computational effect canonically to yield denotational semantics for a corresponding local computational effect. Our leading example yields a construction of the usual denotational semantics for local state from that for global state. Given any Lawvere theory L, possibly countable and possibly enriched, we first give a universal construction that extends L, hence the global operations and equations of a given effect, to incorporate worlds of arbitrary finite size. Then, making delicate use of the final comodel of the ordinary Lawvere theory L, we give a construct that uniformly allows us to model block, the universality of the final comodel yielding a universal property of the construct. We illustrate both the universal extension of L and the canonical construction of block by seeing how they work in the case of state.},
	urldate = {2023-10-23},
	journal = {Electronic Notes in Theoretical Computer Science},
	author = {Power, John},
	month = may,
	year = {2006},
	keywords = {Lawvere theory, global state, indexed Lawvere theory, local state, model, monad},
	pages = {355--371},
}

@article{yang_modular_2023,
	title = {Modular {Models} of {Monoids} with {Operations}},
	volume = {7},
	url = {https://dl.acm.org/doi/10.1145/3607850},
	doi = {10.1145/3607850},
	abstract = {Inspired by algebraic effects and the principle of notions of computations as monoids, we study a categorical framework for equational theories and models of monoids equipped with operations. The framework covers not only algebraic operations but also scoped and variable-binding operations. Appealingly, in this framework both theories and models can be modularly composed. Technically, a general monoid-theory correspondence is shown, saying that the category of theories of algebraic operations is equivalent to the category of monoids. Moreover, more complex forms of operations can be coreflected into algebraic operations, in a way that preserves initial algebras. On models, we introduce modular models of a theory, which can interpret abstract syntax in the presence of other operations. We show constructions of modular models (i) from monoid transformers, (ii) from free algebras, (iii) by composition, and (iv) in symmetric monoidal categories.},
	number = {ICFP},
	urldate = {2023-10-19},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Yang, Zhixuan and Wu, Nicolas},
	month = aug,
	year = {2023},
	keywords = {effects, equational systems, modularity, monad transformers, Σ-monoids},
	pages = {208:566--208:603},
}

@inproceedings{pirog_syntax_2018,
	address = {New York, NY, USA},
	series = {{LICS} '18},
	title = {Syntax and {Semantics} for {Operations} with {Scopes}},
	isbn = {978-1-4503-5583-4},
	url = {https://dl.acm.org/doi/10.1145/3209108.3209166},
	doi = {10.1145/3209108.3209166},
	abstract = {Motivated by the problem of separating syntax from semantics in programming with algebraic effects and handlers, we propose a categorical model of abstract syntax with so-called scoped operations. As a building block of a term, a scoped operation is not merely a node in a tree, as it can also encompass a whole part of the term (a scope). Some examples from the area of programming are given by the operation catch for handling exceptions, in which the part in the scope is the code that may raise an exception, or the operation once, which selects a single solution from a nondeterministic computation. A distinctive feature of such operations is their behaviour under program composition, that is, syntactic substitution. Our model is based on what Ghani et al. call the monad of explicit substitutions, defined using the initial-algebra semantics in the category of endofunctors. We also introduce a new kind of multi-sorted algebras, called scoped algebras, which serve as interpretations of syntax with scopes. In generality, scoped algebras are given in the style of the presheaf formalisation of syntax with binders of Fiore et al. As the main technical result, we show that our monad indeed arises from free objects in the category of scoped algebras. Importantly, we show that our results are immediately applicable. In particular, we show a Haskell implementation together with practical, real-life examples.},
	urldate = {2023-10-19},
	booktitle = {Proceedings of the 33rd {Annual} {ACM}/{IEEE} {Symposium} on {Logic} in {Computer} {Science}},
	publisher = {Association for Computing Machinery},
	author = {Piróg, Maciej and Schrijvers, Tom and Wu, Nicolas and Jaskelioff, Mauro},
	month = jul,
	year = {2018},
	pages = {809--818},
}

@inproceedings{yang_structured_2022,
	address = {Cham},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Structured {Handling} of {Scoped} {Effects}},
	isbn = {978-3-030-99336-8},
	doi = {10.1007/978-3-030-99336-8_17},
	abstract = {Algebraic effects offer a versatile framework that covers a wide variety of effects. However, the family of operations that delimit scopes are not algebraic and are usually modelled as handlers, thus preventing them from being used freely in conjunction with algebraic operations. Although proposals for scoped operations exist, they are either ad-hoc and unprincipled, or too inconvenient for practical programming. This paper provides the best of both worlds: a theoretically-founded model of scoped effects that is convenient for implementation and reasoning. Our new model is based on an adjunction between a locally finitely presentable category and a category of functorial algebras. Using comparison functors between adjunctions, we show that our new model, an existing indexed model, and a third approach that simulates scoped operations in terms of algebraic ones have equal expressivity for handling scoped operations. We consider our new model to be the sweet spot between ease of implementation and structuredness. Additionally, our approach automatically induces fusion laws of handlers of scoped effects, which are useful for reasoning and optimisation.},
	language = {en},
	booktitle = {Programming {Languages} and {Systems}},
	publisher = {Springer International Publishing},
	author = {Yang, Zhixuan and Paviotti, Marco and Wu, Nicolas and van den Berg, Birthe and Schrijvers, Tom},
	editor = {Sergey, Ilya},
	year = {2022},
	keywords = {Abstract syntax, Algebraic theories, Category theory, Computational effects, Handlers, Haskell, Scoped effects},
	pages = {462--491},
}

@article{eilenberg_adjoint_1965,
	title = {Adjoint functors and triples},
	volume = {9},
	issn = {0019-2082},
	doi = {10.1215/ijm/1256068141},
	language = {eng},
	number = {3},
	journal = {Illinois journal of mathematics},
	author = {Eilenberg, Samuel and Moore, John C.},
	year = {1965},
}

@article{hyland_combining_2007,
	title = {Combining algebraic effects with continuations},
	volume = {375},
	issn = {0304-3975},
	doi = {10.1016/j.tcs.2006.12.026},
	abstract = {We consider the natural combinations of algebraic computational effects such as side-effects, exceptions, interactive input/output, and nondeterminism with continuations. Continuations are not an algebraic effect, but previously developed combinations of algebraic effects given by sum and tensor extend, with effort, to include commonly used combinations of the various algebraic effects with continuations. Continuations also give rise to a third sort of combination, that given by applying the continuations monad transformer to an algebraic effect. We investigate the extent to which sum and tensor extend from algebraic effects to arbitrary monads, and the extent to which Felleisen et al.’s
C
operator extends from continuations to its combination with algebraic effects. To do all this, we use Dubuc’s characterisation of strong monads in terms of enriched large Lawvere theories.},
	language = {eng},
	number = {1},
	journal = {Theoretical computer science},
	author = {Hyland, Martin and Levy, Paul Blain and Plotkin, Gordon and Power, John},
	year = {2007},
	note = {Place: Amsterdam
Publisher: Elsevier B.V},
	keywords = {Algorithmics. Computability. Computer arithmetics, Applied sciences, Computational effect, Computer science; control theory; systems, Exact sciences and technology, General logic, Language theory and syntactical analysis, Lawvere theory, Logic and foundations, Mathematical logic, foundations, set theory, Mathematics, Modularity, Monad, Sciences and techniques of general use, Theoretical computing},
	pages = {20--40},
}

@inproceedings{kammar_monad_2017,
	title = {A monad for full ground reference cells},
	url = {https://ieeexplore.ieee.org/document/8005109},
	doi = {10.1109/LICS.2017.8005109},
	abstract = {We present a denotational account of dynamic allocation of potentially cyclic memory cells using a monad on a functor category. We identify the collection of heaps as an object in a different functor category equipped with a monad for adding hiding/encapsulation capabilities to the heaps. We derive a monad for full ground references supporting effect masking by applying a state monad transformer to the encapsulation monad. To evaluate the monad, we present a denotational semantics for a call-by-value calculus with full ground references, and validate associated code transformations.},
	urldate = {2023-10-13},
	booktitle = {2017 32nd {Annual} {ACM}/{IEEE} {Symposium} on {Logic} in {Computer} {Science} ({LICS})},
	author = {Kammar, Ohad and Levy, Paul B. and Moss, Sean K. and Staton, Sam},
	month = jun,
	year = {2017},
	pages = {1--12},
}

@article{sekiyama_temporal_2022,
	title = {Temporal {Verification} with {Answer}-{Effect} {Modification}},
	url = {https://arxiv.org/abs/2207.10386},
	doi = {10.48550/arxiv.2207.10386},
	abstract = {Type-and-effect systems are a widely-used approach to program verification,
verifying the result of a computation using types, and the behavior using
effects. This paper extends an effect system for verifying temporal,
value-dependent properties on event sequences yielded by programs to the
delimited control operators shift0/reset0. While these delimited control
operators enable useful and powerful programming techniques, they hinder
reasoning about the behavior of programs because of their ability to suspend,
resume, discard, and duplicate delimited continuations. This problem is more
serious in effect systems for temporal properties because these systems must be
capable of identifying what event sequences are yielded by captured
continuations. Our key observation for achieving effective reasoning in the
presence of the delimited control operators is that their use modifies answer
effects, which are temporal effects of the continuations. Based on this
observation, we extend an effect system for temporal verification to
accommodate answer-effect modification. Allowing answer-effect modification
enables easily reasoning about traces that captured continuations yield.
Another novel feature of our effect system is the support for dependently-typed
continuations, which allows us to reason about programs more precisely. We
prove soundness of the effect system for finite event sequences via type safety
and that for infinite event sequences using a logical relation.},
	language = {eng},
	urldate = {2023-10-13},
	author = {Sekiyama, Taro and Unno, Hiroshi},
	year = {2022},
	keywords = {Computer Science - Programming Languages},
}

@article{sekiyama_signature_2020,
	title = {Signature restriction for polymorphic algebraic effects},
	volume = {4},
	issn = {2475-1421},
	doi = {10.1145/3408999},
	abstract = {The naive combination of polymorphic effects and polymorphic type assignment has been well known to break type safety. Existing approaches to this problem are classified into two groups: one for restricting how effects are triggered and the other for restricting how they are implemented. This work explores a new approach to ensuring the safety of polymorphic effects in polymorphic type assignment. A novelty of our work lies in finding a restriction on effect interfaces. To formalize our idea, we employ algebraic effects and handlers, where an effect interface is given by a set of operations coupled with type signatures. We propose signature restriction, a new notion to restrict the type signatures of operations, and show that signature restriction is sufficient to ensure type safety of an effectful language equipped with unrestricted polymorphic type assignment. We also develop a type-and-effect system to enable the use of both operations that satisfy and do not satisfy the signature restriction in a single program.},
	language = {eng},
	number = {ICFP},
	journal = {Proceedings of ACM on programming languages},
	author = {Sekiyama, Taro and Tsukada, Takeshi and Igarashi, Atsushi},
	year = {2020},
	note = {Place: Ithaca
Publisher: ACM},
	keywords = {Algebra, Computer Science - Programming Languages, Safety, Signatures, algebraic effects and handlers, polymorphic effects, polymorphic type assignment},
	pages = {1--30},
}

@article{plotkin_handling_2013,
	title = {Handling {Algebraic} {Effects}},
	volume = {9, Issue 4},
	issn = {1860-5974},
	doi = {10.2168/LMCS-9(4:23)2013},
	abstract = {Algebraic effects are computational effects that can be represented by an equational theory whose operations produce the effects at hand. The free model of this theory induces the expected computational monad for the corresponding effect. Algebraic effects include exceptions, state, nondeterminism, interactive input/output, and time, and their combinations. Exception handling, however, has so far received no algebraic treatment. We present such a treatment, in which each handler yields a model of the theory for exceptions, and each handling construct yields the homomorphism induced by the universal property of the free model. We further generalise exception handlers to arbitrary algebraic effects. The resulting programming construct includes many previously unrelated examples from both theory and practice, including relabelling and restriction in Milner's CCS, timeout, rollback, and stream redirection.},
	language = {eng},
	journal = {Logical methods in computer science},
	author = {Plotkin, Gordon D. and Pretnar, Matija},
	year = {2013},
	note = {Place: Ithaca
Publisher: Cornell University Library, arXiv.org},
	keywords = {Algebra, Computation, Exception handling, Homomorphisms, computer science - logic in computer science, computer science - programming languages},
}

@article{ager_functional_2003,
	title = {A {Functional} {Correspondence} between {Monadic} {Evaluators} and {Abstract} {Machines} for {Languages} with {Computational} {Effects}},
	volume = {10},
	issn = {0909-0878},
	doi = {10.7146/brics.v10i35.21803},
	abstract = {We extend our correspondence between evaluators and abstract machines from the pure setting of the lambda-calculus to the impure setting of the computational lambda-calculus. Specifically, we show how to derive new abstract machines from monadic evaluators for the computational lambda-calculus. Starting from a monadic evaluator and a given monad, we inline the components of the monad in the evaluator and we derive the corresponding abstract machine by closure-converting, CPS-transforming, and defunctionalizing this inlined interpreter. We illustrate the construction first with the identity monad, obtaining yet again the CEK machine, and then with a state monad, an exception monad, and a combination of both.
In addition, we characterize the tail-recursive stack inspection presented by Clements and Felleisen at ESOP 2003 as a canonical state monad. Combining this state monad with an exception monad, we construct an abstract machine for a language with exceptions and properly tail-recursive stack inspection. The construction scales to other monads--including one more properly dedicated to stack inspection than the state monad--and other monadic evaluators.},
	language = {eng},
	number = {35},
	journal = {BRICS Report Series},
	author = {Ager, Mads Sig and Danvy, Olivier and Midtgaard, Jan},
	year = {2003},
}

@inproceedings{filinski_representing_1999,
	title = {Representing layered monads},
	isbn = {978-1-58113-095-9},
	doi = {10.1145/292540.292557},
	abstract = {There has already been considerable research on constructing modular, monad-based specifications of computational effects (state, exceptions, nondeterminism, etc.) in programming languages. We present a simple framework in this tradition, based on a Church-style effect-typing system for an ML-like language. The semantics of this language is formally defined by a series of monadic translations, each one expanding away a layer of effects. Such a layered specification is easy to reason about, but its direct implementation (whether by parameterized interpretation or by actual translation) is often prohibitively inefficient.By exploiting deeper semantic properties of monads, however, it is also possible to derive a vastly more efficient implementation: we show that each layer of effects can be uniformly simulated by continuation-passing, and further that multiple such layers can themselves be simulated by a standard semantics for call/cc and mutable state. Thus, even multi-effect programs can be executed in Scheme or SML/NJ at full native speed, generalizing an earlier single-effect result. As an example, we show how a simple resumption-based semantics of concurrency allows us to directly simulate a shared-state program across all possible dynamic interleavings of execution threads.},
	language = {eng},
	publisher = {ACM},
	author = {Filinski, Andrzej},
	year = {1999},
	note = {Book Title: Annual Symposium on Principles of Programming Languages: Proceedings of the 26th ACM SIGPLAN-SIGACT symposium on Principles of programming languages; 20-22 Jan. 1999},
	pages = {175--188},
}

@article{kelly_unified_1980,
	title = {A unified treatment of transfinite constructions for free algebras, free monoids, colimits, associated sheaves, and so on},
	volume = {22},
	issn = {0004-9727},
	doi = {10.1017/S0004972700006353},
	abstract = {Many problems lead to the consideration of “algebras”, given by an object A of a category A together with “actions” TkA → A on A of one or more endofunctors of A, subjected to equational axioms. Such problems include those of free monads and free monoids, of cocompleteness in categories of monads and of monoids, of orthogonal subcategories (= generalized sheaf-categories), of categories of continuous functors, and so on; apart from problems involving the algebras for their own sake. Desirable properties of the category of algebras - existence of free ones, cocompleteness, existence of adjoints to algebraic functors - all follow if this category can be proved reflective in some well-behaved category: for which we choose a certain comma-category T/A We show that the reflexion exists and is given as the colimit of a simple transfinite sequence, if A is cocomplete and the Tk preserve either colimits or unions of suitably-long chains of subobjects. The article draws heavily on the work of earlier authors, unifies and simplifies this, and extends it to new problems. Moreover the reflectivity in T/A is stronger than any earlier result, and will be applied in forthcoming articles, in an enriched version, to the study of categories with structure.},
	language = {eng},
	number = {1},
	journal = {Bulletin of the Australian Mathematical Society},
	author = {Kelly, G. M.},
	year = {1980},
	note = {Place: Cambridge, UK
Publisher: Cambridge University Press},
	pages = {1--83},
}

@article{hyland_discrete_2006,
	title = {Discrete {Lawvere} theories and computational effects},
	volume = {366},
	issn = {0304-3975},
	doi = {10.1016/j.tcs.2006.07.007},
	abstract = {Countable Lawvere theories model computational effects such as exceptions, side-effects, interactive input/output, nondeterminism and probabilistic nondeterminism. The category of countable Lawvere theories has sums, tensors, and distributive tensors, modelling natural combinations of such effects. It is also closed under taking images. Enrichment in a category such as
ω
Cpo
allows one to extend this modelling of computational effects to account for partiality and recursion. Sum and tensor extend to enriched countable Lawvere theories, but distributive tensor and image do not. So here we introduce discrete countable enriched Lawvere theories in order to allow natural definitions and accounts of distributive tensor and image. A discrete countable enriched Lawvere theory is, in a sense we make precise, an enriched Lawvere theory with discrete arities. We show that they include all our leading examples of computational effects and are closed under sum and tensor. And we develop notions of enriched operad and enriched multicategory to support the definition.},
	language = {eng},
	number = {1},
	journal = {Theoretical computer science},
	author = {Hyland, Martin and Power, John},
	year = {2006},
	note = {Place: Amsterdam
Publisher: Elsevier B.V},
	keywords = {Algebra, Algorithmics. Computability. Computer arithmetics, Applied sciences, Category theory, homological algebra, Computer science; control theory; systems, Countable Lawvere V-theory, Discrete countable Lawvere V-theory, Distributive tensor, Exact sciences and technology, General algebraic systems, Logic and foundations, Mathematical logic, foundations, set theory, Mathematics, Model theory, Sciences and techniques of general use, Sum, Tensor, Theoretical computing},
	pages = {144--162},
}

@article{mohri_semiring_2002,
	title = {Semiring frameworks and algorithms for shortest-distance problems},
	volume = {7},
	issn = {1430-189X},
	doi = {10.25596/jalc-2002-321},
	abstract = {We define general algebraic frameworks for shortest-distance problems based on the structure of semirings. We give a generic algorithm for finding single-source shortest distances in a weighted directed graph when the weights satisfy the conditions of our general semiring framework. The same algorithm can be used to solve efficiently classical shortest paths problems or to find the k-shortest distances in a directed graph. It can be used to solve single-source shortest-distance problems in weighted directed acyclic graphs over any semiring. We examine several semirings and describe some specific instances of our generic algorithms to illustrate their use and compare them with existing methods and algorithms. The proof of the soundness of all algorithms is given in detail, including their pseudocode and a full analysis of their running time complexity.},
	number = {3},
	journal = {Journal of Automata, Languages and Combinatorics},
	author = {Mohri, Mehryar},
	month = jan,
	year = {2002},
	keywords = {finite automata, rational power series, semirings, shortest-paths algorithms},
	pages = {321--350},
}

@article{carette_finally_2009,
	title = {Finally tagless, partially evaluated: {Tagless} staged interpreters for simpler typed languages},
	volume = {19},
	issn = {0956-7968},
	shorttitle = {Finally tagless, partially evaluated},
	doi = {10.1017/S0956796809007205},
	abstract = {We have built the first family of tagless interpretations for a higher-order typed object language in a typed metalanguage (Haskell or ML) that require no dependent types, generalized algebraic data types, or postprocessing to eliminate tags. The statically type-preserving interpretations include an evaluator, a compiler (or staged evaluator), a partial evaluator, and call-by-name and call-by-value continuation-passing style (CPS) transformers. Our principal technique is to encode de Bruijn or higher-order abstract syntax using combinator functions rather than data constructors. In other words, we represent object terms not in an initial algebra but using the coalgebraic structure of the λ-calculus. Our representation also simulates inductive maps from types to types, which are required for typed partial evaluation and CPS transformations. Our encoding of an object term abstracts uniformly over the family of ways to interpret it, yet statically assures that the interpreters never get stuck. This family of interpreters thus demonstrates again that it is useful to abstract over higher-kinded types.},
	language = {eng},
	number = {5},
	journal = {Journal of functional programming},
	author = {Carette, Jacques and Kiselyov, Oleg and Shan, Chung-Chieh},
	year = {2009},
	note = {Place: Cambridge, UK
Publisher: Cambridge University Press},
	pages = {509--543},
}

@article{lawvere_functorial_1963,
	title = {Functorial {Semantics} of {Algebraic} {Theories}},
	volume = {50},
	issn = {0027-8424},
	doi = {10.1073/pnas.50.5.869},
	language = {eng},
	number = {5},
	journal = {Proceedings of the National Academy of Sciences - PNAS},
	author = {Lawvere, F. William},
	year = {1963},
	note = {Place: United States
Publisher: National Academy of Sciences of the United States of America},
	keywords = {Abstract algebra, Adjoints, Algebra, Functors, Mathematical objects, Mathematical rings, Mathematical sets, Mathematical theorems, Mathematics, Monoids},
	pages = {869--872},
}

@article{hyland_category_2007,
	title = {The {Category} {Theoretic} {Understanding} of {Universal} {Algebra}: {Lawvere} {Theories} and {Monads}},
	volume = {172},
	issn = {1571-0661},
	shorttitle = {The {Category} {Theoretic} {Understanding} of {Universal} {Algebra}},
	doi = {10.1016/j.entcs.2007.02.019},
	abstract = {Lawvere theories and monads have been the two main category theoretic formulations of universal algebra, Lawvere theories arising in 1963 and the connection with monads being established a few years later. Monads, although mathematically the less direct and less malleable formulation, rapidly gained precedence. A generation later, the definition of monad began to appear extensively in theoretical computer science in order to model computational effects, without reference to universal algebra. But since then, the relevance of universal algebra to computational effects has been recognised, leading to renewed prominence of the notion of Lawvere theory, now in a computational setting. This development has formed a major part of Gordon Plotkin's mature work, and we study its history here, in particular asking why Lawvere theories were eclipsed by monads in the 1960's, and how the renewed interest in them in a computer science setting might develop in future.},
	language = {eng},
	journal = {Electronic notes in theoretical computer science},
	author = {Hyland, Martin and Power, John},
	year = {2007},
	note = {Publisher: Elsevier B.V},
	keywords = {Lawvere theory, Universal algebra, computational effect, monad},
	pages = {437--458},
}

@incollection{sekiyama_handling_2019,
	address = {Ithaca},
	title = {Handling polymorphic algebraic effects},
	abstract = {Algebraic effects and handlers are a powerful abstraction mechanism to represent and implement control effects. In this work, we study their extension with parametric polymorphism that allows abstracting not only expressions but also effects and handlers. Although polymorphism makes it possible to reuse and reason about effect implementations more effectively, it has long been known that a naive combination of polymorphic effects and let-polymorphism breaks type safety. Although type safety can often be gained by restricting let-bound expressions---e.g., by adopting value restriction or weak polymorphism---we propose a complementary approach that restricts handlers instead of let-bound expressions. Our key observation is that, informally speaking, a handler is safe if resumptions from the handler do not interfere with each other. To formalize our idea, we define a call-by-value lambda calculus that supports let-polymorphism and polymorphic algebraic effects and handlers, design a type system that rejects interfering handlers, and prove type safety of our calculus.},
	language = {eng},
	booktitle = {{arXiv}.org},
	publisher = {Cornell University Library, arXiv.org},
	author = {Sekiyama, Taro and Igarashi, Atsushi},
	year = {2019},
	doi = {10.1007/978-3-030-17184-1_13},
	note = {ISSN: 2331-8422},
	keywords = {Algebra, Computer Science - Programming Languages, Polymorphism, Safety},
}

@book{aho_compilers_2014,
	address = {Harlow},
	edition = {Second edition, Pearson New International edition.},
	series = {Pearson custom library},
	title = {Compilers: principles, techniques, and tools},
	isbn = {978-1-292-02434-9},
	shorttitle = {Compilers},
	language = {eng},
	publisher = {Pearson Education Limited},
	author = {Aho, Alfred V. and Lam, Monica S. and Sethi, Ravi and Ullman, Jeffrey D.},
	year = {2014},
	keywords = {Compilers (Computer programs)},
}

@article{power_enriched_1999,
	title = {Enriched {Lawvere} theories},
	volume = {6},
	url = {https://solo.bodleian.ox.ac.uk/discovery/fulldisplay/cdi_scopus_primary_31692690/44OXF_INST:SOLO},
	abstract = {We define the notion of enriched Lawvere theory, for enrichment over a monoidal biclosed category \$V\$ that is locally finitely presentable as a closed category. We prove that the category of enriched Lawvere theories is equivalent to the category of finitary monads on \$V\$. Moreover, the \$V\$-category of models of a Lawvere \$V\$-theory is equivalent to the \$V\$-category of algebras for the corresponding \$V\$-monad. This all extends routinely to local presentability with respect to any regular cardinal. We finally consider the special case where \$V\$ is \$Cat\$, and explain how the correspondence extends to pseudo maps of algebras.},
	language = {en},
	urldate = {2023-09-06},
	journal = {Theory and Applications of Categories},
	author = {Power, John},
	year = {1999},
	pages = {83--93},
}

@article{hyland_combining_2006,
	title = {Combining effects: {Sum} and tensor},
	volume = {357},
	issn = {0304-3975},
	shorttitle = {Combining effects},
	doi = {10.1016/j.tcs.2006.03.013},
	abstract = {We seek a unified account of modularity for computational effects. We begin by reformulating Moggi's monadic paradigm for modelling computational effects using the notion of enriched Lawvere theory, together with its relationship with strong monads; this emphasises the importance of the operations that produce the effects. Effects qua theories are then combined by appropriate bifunctors on the category of theories. We give a theory for the sum of computational effects, which in particular yields Moggi's exceptions monad transformer and an interactive input/output monad transformer. We further give a theory of the commutative combination of effects, their tensor, which yields Moggi's side-effects monad transformer. Finally, we give a theory of operation transformers, for redefining operations when adding new effects; we derive explicit forms for the operation transformers associated to the above monad transformers.},
	language = {eng},
	number = {1},
	journal = {Theoretical computer science},
	author = {Hyland, Martin and Plotkin, Gordon and Power, John},
	year = {2006},
	note = {Place: Amsterdam
Publisher: Elsevier B.V},
	keywords = {Algebra, Algorithmics. Computability. Computer arithmetics, Applied sciences, Category theory, homological algebra, Computational effect, Computer science; control theory; systems, Exact sciences and technology, General logic, Lawvere theory, Logic and foundations, Mathematical logic, foundations, set theory, Mathematics, Modularity, Monad, Sciences and techniques of general use, Theoretical computing},
	pages = {70--99},
}

@phdthesis{cheung_distributive_2017,
	title = {Distributive {Interaction} of {Algebraic} {Eﬀects}},
	language = {en},
	school = {University of Oxford},
	author = {Cheung, Kwok-Ho},
	year = {2017},
}

@article{moggi_notions_1991,
	title = {Notions of computation and monads},
	volume = {93},
	issn = {0890-5401},
	doi = {10.1016/0890-5401(91)90052-4},
	abstract = {The λ-calculus is considered a useful mathematical tool in the study of programming languages, since programs can be
identified with λ-terms. However, if one goes further and uses βη-conversion to prove equivalence of programs, then a gross simplification is introduced (programs are identified with total functions from
values to
values) that may jeopardise the applicability of theoretical results. In this paper we introduce calculi, based on a categorical semantics for
computations, that provide a correct basis for proving equivalence of programs for a wide range of
notions of computation.},
	language = {eng},
	number = {1},
	journal = {Information and computation},
	author = {Moggi, Eugenio},
	year = {1991},
	note = {Place: San Diego, CA
Publisher: Elsevier Inc},
	keywords = {Applied sciences, Computer science; control theory; systems, Exact sciences and technology, Programming theory, Theoretical computing},
	pages = {55--92},
}

@misc{skorstengaard_introduction_2019,
	title = {An {Introduction} to {Logical} {Relations}},
	url = {http://arxiv.org/abs/1907.11133},
	doi = {10.48550/arXiv.1907.11133},
	abstract = {Logical relations (LR) have been around for many years, and today they are used in many formal results. However, it can be difficult to LR beginners to find a good place to start to learn. Papers often use highly specialized LRs that use the latest advances of the technique which makes it impossible to make a proper presentation within the page limit. This note is a good starting point for beginners that want to learn about LRs. Almost no prerequisite knowledge is assumed, and the note starts from the very basics. The note covers the following: LRs for proving normalization and type safety of simply typed lambda calculus, relational substitutions for reasoning about universal and existential types, step-indexing for reasoning about recursive types, and worlds for reasoning about references.},
	urldate = {2023-08-04},
	publisher = {arXiv},
	author = {Skorstengaard, Lau},
	month = jul,
	year = {2019},
	note = {arXiv:1907.11133 [cs]},
	keywords = {Computer Science - Programming Languages},
}

@inproceedings{oliveira_disjoint_2016,
	address = {New York, NY, USA},
	series = {{ICFP} 2016},
	title = {Disjoint intersection types},
	isbn = {978-1-4503-4219-3},
	url = {https://dl.acm.org/doi/10.1145/2951913.2951945},
	doi = {10.1145/2951913.2951945},
	abstract = {Dunfield showed that a simply typed core calculus with intersection types and a merge operator is able to capture various programming language features. While his calculus is type-safe, it is not coherent: different derivations for the same expression can elaborate to expressions that evaluate to different values. The lack of coherence is an important disadvantage for adoption of his core calculus in implementations of programming languages, as the semantics of the programming language becomes implementation-dependent. This paper presents λ\_i: a coherent and type-safe calculus with a form of intersection types and a merge operator. Coherence is achieved by ensuring that intersection types are disjoint and programs are sufficiently annotated to avoid type ambiguity. We propose a definition of disjointness where two types A and B are disjoint only if certain set of types are common supertypes of A and B. We investigate three different variants of λ\_i, with three variants of disjointness. In the simplest variant, which does not allow ⊤ types, two types are disjoint if they do not share any common supertypes at all. The other two variants introduce ⊤ types and refine the notion of disjointness to allow two types to be disjoint when the only the set of common supertypes are top-like. The difference between the two variants with ⊤ types is on the definition of top-like types, which has an impact on which types are allowed on intersections. We present a type system that prevents intersection types that are not disjoint, as well as an algorithmic specifications to determine whether two types are disjoint for all three variants.},
	urldate = {2023-06-19},
	booktitle = {Proceedings of the 21st {ACM} {SIGPLAN} {International} {Conference} on {Functional} {Programming}},
	publisher = {Association for Computing Machinery},
	author = {Oliveira, Bruno C. d. S. and Shi, Zhiyuan and Alpuim, João},
	month = sep,
	year = {2016},
	keywords = {Intersection Types, Type System},
	pages = {364--377},
}

@article{dunfield_elaborating_2012,
	title = {Elaborating intersection and union types},
	volume = {47},
	issn = {0362-1340},
	doi = {10.1145/2398856.2364534},
	abstract = {Designing and implementing typed programming languages is hard. Every new type system feature requires extending the metatheory and implementation, which are often complicated and fragile. To ease this process, we would like to provide general mechanisms that subsume many different features. In modern type systems, parametric polymorphism is fundamental, but intersection polymorphism has gained little traction in programming languages. Most practical intersection type systems have supported only refinement intersections , which increase the expressiveness of types (more precise properties can be checked) without altering the expressiveness of terms; refinement intersections can simply be erased during compilation. In contrast, unrestricted intersections increase the expressiveness of terms, and can be used to encode diverse language features, promising an economy of both theory and implementation. We describe a foundation for compiling unrestricted intersection and union types: an elaboration type system that generates ordinary λ -calculus terms. The key feature is a Forsythe-like merge construct. With this construct, not all reductions of the source program preserve types; however, we prove that ordinary call-by-value evaluation of the elaborated program corresponds to a type-preserving evaluation of the source program. We also describe a prototype implementation and applications of unrestricted intersections and unions: records, operator overloading, and simulating dynamic typing.},
	language = {eng},
	number = {9},
	journal = {SIGPLAN notices},
	author = {Dunfield, Jana},
	year = {2012},
	pages = {17--28},
}

@article{ghilezan_strong_1996,
	title = {Strong {Normalization} and {Typability} with {Intersection} {Types}},
	volume = {37},
	issn = {0029-4527, 1939-0726},
	url = {https://projecteuclid.org/journals/notre-dame-journal-of-formal-logic/volume-37/issue-1/Strong-Normalization-and-Typability-with-Intersection-Types/10.1305/ndjfl/1040067315.full},
	doi = {10.1305/ndjfl/1040067315},
	abstract = {A simple proof is given of the property that the set of strongly normalizing lambda terms coincides with the set of lambda terms typable in certain intersection type assignment systems.},
	number = {1},
	urldate = {2023-06-16},
	journal = {Notre Dame Journal of Formal Logic},
	author = {Ghilezan, Silvia},
	month = jan,
	year = {1996},
	note = {Publisher: Duke University Press},
	keywords = {03B15, 03B40, 03B70, 68Q55},
	pages = {44--52},
}

@misc{miceli-barone_larger_2023,
	title = {The {Larger} {They} {Are}, the {Harder} {They} {Fail}: {Language} {Models} do not {Recognize} {Identifier} {Swaps} in {Python}},
	shorttitle = {The {Larger} {They} {Are}, the {Harder} {They} {Fail}},
	url = {http://arxiv.org/abs/2305.15507},
	doi = {10.48550/arXiv.2305.15507},
	abstract = {Large Language Models (LLMs) have successfully been applied to code generation tasks, raising the question of how well these models understand programming. Typical programming languages have invariances and equivariances in their semantics that human programmers intuitively understand and exploit, such as the (near) invariance to the renaming of identifiers. We show that LLMs not only fail to properly generate correct Python code when default function names are swapped, but some of them even become more confident in their incorrect predictions as the model size increases, an instance of the recently discovered phenomenon of Inverse Scaling, which runs contrary to the commonly observed trend of increasing prediction quality with increasing model size. Our findings indicate that, despite their astonishing typical-case performance, LLMs still lack a deep, abstract understanding of the content they manipulate, making them unsuitable for tasks that statistically deviate from their training data, and that mere scaling is not enough to achieve such capability.},
	urldate = {2023-05-29},
	publisher = {arXiv},
	author = {Miceli-Barone, Antonio Valerio and Barez, Fazl and Konstas, Ioannis and Cohen, Shay B.},
	month = may,
	year = {2023},
	note = {arXiv:2305.15507 [cs]},
	keywords = {Computer Science - Artificial Intelligence, Computer Science - Computation and Language},
}

@misc{bauer_what_2019,
	title = {What is algebraic about algebraic effects and handlers?},
	url = {http://arxiv.org/abs/1807.05923},
	doi = {10.48550/arXiv.1807.05923},
	abstract = {This note recapitulates and expands the contents of a tutorial on the mathematical theory of algebraic effects and handlers which I gave at the Dagstuhl seminar 18172 "Algebraic effect handlers go mainstream". It is targeted roughly at the level of a doctoral student with some amount of mathematical training, or at anyone already familiar with algebraic effects and handlers as programming concepts who would like to know what they have to do with algebra. We draw an uninterrupted line of thought between algebra and computational effects. We begin on the mathematical side of things, by reviewing the classic notions of universal algebra: signatures, algebraic theories, and their models. We then generalize and adapt the theory so that it applies to computational effects. In the last step we replace traditional mathematical notation with one that is closer to programming languages.},
	urldate = {2023-05-08},
	publisher = {arXiv},
	author = {Bauer, Andrej},
	month = mar,
	year = {2019},
	note = {arXiv:1807.05923 [cs]},
	keywords = {08A70, Computer Science - Logic in Computer Science, Computer Science - Programming Languages},
}

@misc{noauthor_mathematical_nodate,
	title = {A {Mathematical} {Framework} for {Transformer} {Circuits}},
	url = {https://transformer-circuits.pub/2021/framework/index.html},
	urldate = {2023-05-08},
}

@incollection{fleet_visualizing_2014,
	address = {Cham},
	title = {Visualizing and {Understanding} {Convolutional} {Networks}},
	volume = {8689},
	isbn = {978-3-319-10589-5 978-3-319-10590-1},
	url = {http://link.springer.com/10.1007/978-3-319-10590-1_53},
	language = {en},
	urldate = {2023-05-08},
	booktitle = {Computer {Vision} – {ECCV} 2014},
	publisher = {Springer International Publishing},
	author = {Zeiler, Matthew D. and Fergus, Rob},
	editor = {Fleet, David and Pajdla, Tomas and Schiele, Bernt and Tuytelaars, Tinne},
	year = {2014},
	doi = {10.1007/978-3-319-10590-1_53},
	note = {Series Title: Lecture Notes in Computer Science},
	pages = {818--833},
}

@inproceedings{nguyen_deep_2015,
	address = {Boston, MA, USA},
	title = {Deep neural networks are easily fooled: {High} confidence predictions for unrecognizable images},
	isbn = {978-1-4673-6964-0},
	shorttitle = {Deep neural networks are easily fooled},
	url = {http://ieeexplore.ieee.org/document/7298640/},
	doi = {10.1109/CVPR.2015.7298640},
	urldate = {2023-05-08},
	booktitle = {2015 {IEEE} {Conference} on {Computer} {Vision} and {Pattern} {Recognition} ({CVPR})},
	publisher = {IEEE},
	author = {Nguyen, Anh and Yosinski, Jason and Clune, Jeff},
	month = jun,
	year = {2015},
	pages = {427--436},
}

@inproceedings{plotkin_adequacy_2001,
	address = {Berlin, Heidelberg},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Adequacy for {Algebraic} {Effects}},
	isbn = {978-3-540-45315-4},
	doi = {10.1007/3-540-45315-6_1},
	abstract = {Moggi proposed a monadic account of computational effects. He also presented the computational λ-calculus, λc, a core call-by-value functional programming language for effects; the effects are obtained by adding appropriate operations. The question arises as to whether one can give a corresponding treatment of operational semantics. We do this in the case of algebraic effects where the operations are given by a single-sorted algebraic signature, and their semantics is supported by the monad, in a certain sense. We consider call-by-value PCF with— and without—recursion, an extension of λcwith arithmetic. We prove general adequacy theorems, and illustrate these with two examples: non-determinism and probabilistic nondeterminism.},
	language = {en},
	booktitle = {Foundations of {Software} {Science} and {Computation} {Structures}},
	publisher = {Springer},
	author = {Plotkin, Gordon and Power, John},
	editor = {Honsell, Furio and Miculan, Marino},
	year = {2001},
	keywords = {Closed Term, Denotational Semantic, Operation Symbol, Operational Semantic, Probabilistic Choice},
	pages = {1--24},
}

@article{plotkin_algebraic_2003,
	title = {Algebraic {Operations} and {Generic} {Effects}},
	volume = {11},
	issn = {1572-9095},
	url = {https://doi.org/10.1023/A:1023064908962},
	doi = {10.1023/A:1023064908962},
	abstract = {Given a complete and cocomplete symmetric monoidal closed category V and a symmetric monoidal V-category C with cotensors and a strong V-monad T on C, we investigate axioms under which an ObC-indexed family of operations of the form αx:(Tx)v→(Tx)wprovides semantics for algebraic operations on the computational λ-calculus. We recall a definition for which we have elsewhere given adequacy results, and we show that an enrichment of it is equivalent to a range of other possible natural definitions of algebraic operation. In particular, we define the notion of generic effect and show that to give a generic effect is equivalent to giving an algebraic operation. We further show how the usual monadic semantics of the computational λ-calculus extends uniformly to incorporate generic effects. We outline examples and non-examples and we show that our definition also enriches one for call-by-name languages with effects.},
	language = {en},
	number = {1},
	urldate = {2023-04-21},
	journal = {Applied Categorical Structures},
	author = {Plotkin, Gordon and Power, John},
	month = feb,
	year = {2003},
	keywords = {Lawvere theory, algebraic operation, computational effect, monad},
	pages = {69--94},
}

@article{pretnar_introduction_2015,
	series = {The 31st {Conference} on the {Mathematical} {Foundations} of {Programming} {Semantics} ({MFPS} {XXXI}).},
	title = {An {Introduction} to {Algebraic} {Effects} and {Handlers}. {Invited} tutorial paper},
	volume = {319},
	issn = {1571-0661},
	url = {https://www.sciencedirect.com/science/article/pii/S1571066115000705},
	doi = {10.1016/j.entcs.2015.12.003},
	abstract = {This paper is a tutorial on algebraic effects and handlers. In it, we explain what algebraic effects are, give ample examples to explain how handlers work, define an operational semantics and a type \& effect system, show how one can reason about effects, and give pointers for further reading.},
	language = {en},
	urldate = {2023-04-20},
	journal = {Electronic Notes in Theoretical Computer Science},
	author = {Pretnar, Matija},
	month = dec,
	year = {2015},
	keywords = {algebraic effects, effect system, handlers, logic, semantics, tutorial},
	pages = {19--35},
}

@book{golan_semirings_1999,
	address = {Dordrecht ; Boston},
	edition = {1999th edition},
	title = {Semirings and their {Applications}},
	isbn = {978-0-7923-5786-5},
	abstract = {There is no branch of mathematics, however abstract, which may not some day be applied to phenomena of the real world. - Nikolai Ivanovich Lobatchevsky This book is an extensively-revised and expanded version of "The Theory of Semirings, with Applicationsin Mathematics and Theoretical Computer Science" [Golan, 1992], first published by Longman. When that book went out of print, it became clear - in light of the significant advances in semiring theory over the past years and its new important applications in such areas as idempotent analysis and the theory of discrete-event dynamical systems - that a second edition incorporating minor changes would not be sufficient and that a major revision of the book was in order. Therefore, though the structure of the first «dition was preserved, the text was extensively rewritten and substantially expanded. In particular, references to many interesting and applications of semiring theory, developed in the past few years, had to be added. Unfortunately, I find that it is best not to go into these applications in detail, for that would entail long digressions into various domains of pure and applied mathematics which would only detract from the unity of the volume and increase its length considerably. However, I have tried to provide an extensive collection of examples to arouse the reader's interest in applications, as well as sufficient citations to allow the interested reader to locate them. For the reader's convenience, an index to these citations is given at the end of the book .},
	language = {English},
	publisher = {Springer},
	author = {Golan, Jonathan S.},
	month = jul,
	year = {1999},
}

@inproceedings{yang_fantastic_2022,
	address = {Cham},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Fantastic {Morphisms} and {Where} to {Find} {Them}},
	isbn = {978-3-031-16912-0},
	doi = {10.1007/978-3-031-16912-0_9},
	abstract = {Structured recursion schemes have been widely used in constructing, optimizing, and reasoning about programs over inductive and coinductive datatypes. Their plain forms, catamorphisms and anamorphisms, are restricted in expressivity. Thus many generalizations have been proposed, which further led to several unifying frameworks of structured recursion schemes. However, the existing work on unifying frameworks typically focuses on the categorical foundation, and thus is perhaps inaccessible to practitioners who are willing to apply recursion schemes in practice but are not versed in category theory. To fill this gap, this expository paper introduces structured recursion schemes from a practical point of view: a variety of recursion schemes are motivated and explained in contexts of concrete programming examples. The categorical duals of these recursion schemes are also explained.},
	language = {en},
	booktitle = {Mathematics of {Program} {Construction}},
	publisher = {Springer International Publishing},
	author = {Yang, Zhixuan and Wu, Nicolas},
	editor = {Komendantskaya, Ekaterina},
	year = {2022},
	keywords = {(Co)Inductive datatypes, (Un)Folds, Equational reasoning, Generic programming, Haskell, Recursion schemes},
	pages = {222--267},
}

@article{jun_ideals_2003,
	title = {On {Ideals} in {Subtraction} {Algebras}},
	volume = {128},
	abstract = {The ideal generated by a set is established, and related results are discussed.},
	language = {en},
	number = {1},
	journal = {Mathematica Bohemica},
	author = {Jun, Young Bae and Kim, Hee Sik},
	year = {2003},
	pages = {21--24},
}

@article{kim_subtraction_2003,
	title = {Subtraction algebras and \${BCK}\$-algebras},
	volume = {128},
	issn = {0862-7959},
	url = {https://eudml.org/doc/249225},
	language = {eng},
	number = {1},
	urldate = {2023-03-23},
	journal = {Mathematica Bohemica},
	author = {Kim, Young Hee and Kim, Hee Sik},
	year = {2003},
	note = {Publisher: Institute of Mathematics, Academy of Sciences of the Czech Republic},
	pages = {21--24},
}

@article{ozturk_homomorphism_2013,
	title = {Homomorphism theorems in subtraction algebra},
	volume = {44},
	issn = {0049-2930},
	doi = {10.5556/j.tkjm.44.2013.978},
	abstract = {In this paper, we give homomorphism theorem between two subtraction algebras and investigate some related properties.},
	language = {eng},
	number = {4},
	journal = {Tamkang journal of mathematics},
	author = {öztürk, Mehmet ali and Yazarli, Hasret},
	year = {2013},
	pages = {365--375},
}

@misc{sennesh_computing_2023,
	title = {Computing with {Categories} in {Machine} {Learning}},
	url = {http://arxiv.org/abs/2303.04156},
	doi = {10.48550/arXiv.2303.04156},
	abstract = {Category theory has been successfully applied in various domains of science, shedding light on universal principles unifying diverse phenomena and thereby enabling knowledge transfer between them. Applications to machine learning have been pursued recently, and yet there is still a gap between abstract mathematical foundations and concrete applications to machine learning tasks. In this paper we introduce DisCoPyro as a categorical structure learning framework, which combines categorical structures (such as symmetric monoidal categories and operads) with amortized variational inference, and can be applied, e.g., in program learning for variational autoencoders. We provide both mathematical foundations and concrete applications together with comparison of experimental performance with other models (e.g., neuro-symbolic models). We speculate that DisCoPyro could ultimately contribute to the development of artificial general intelligence.},
	urldate = {2023-03-09},
	publisher = {arXiv},
	author = {Sennesh, Eli and Xu, Tom and Maruyama, Yoshihiro},
	month = mar,
	year = {2023},
	note = {arXiv:2303.04156 [cs, math, stat]},
	keywords = {Computer Science - Artificial Intelligence, Computer Science - Machine Learning, Mathematics - Category Theory, Statistics - Machine Learning},
}

@article{gibbons_origami_2003,
	title = {Origami {Programming}},
	abstract = {One style of functional programming is based purely on recursive equations. Such equations are easy to explain, and adequate for any computational purpose, but hard to use well as programs get bigger and more complicated. In a sense, recursive equations are the `assembly language' of functional programming, and direct recursion the goto. As computer scientists discovered in the 1960s with structured programming, it is better to identify common patterns of use of such too-powerful tools, and capture these patterns as new constructions and abstractions. In functional programming, in contrast to imperative programming, we can often express the new constructions as higher-order operations within the language, whereas the move from unstructured to structured programming entailed the development of new languages. In this chapter we will look at folds and unfolds as abstractions. In a precise technical sense, folds and unfolds are the natural patterns of computation over recursive datatypes; unfolds generate data structures and folds consume them. Functional programmers are very familiar with the foldr function on lists, and its directional dual foldl; they are gradually coming to terms with the generalisation to folds on other datatypes. The computational duals, unfolds, are still rather unfamiliar; we hope to show here that they are no more complicated than, and just as useful as, folds, and to promote a style of programming based on these and similar recursion patterns.},
	author = {Gibbons, Jeremy},
	year = {2003},
}

@book{nielsen_neural_2015,
	title = {Neural {Networks} and {Deep} {Learning}},
	url = {http://neuralnetworksanddeeplearning.com},
	language = {en},
	urldate = {2023-03-05},
	publisher = {Determination Press},
	author = {Nielsen, Michael A.},
	year = {2015},
}

@article{lehmann_algebraic_1977,
	title = {Algebraic structures for transitive closure},
	volume = {4},
	issn = {0304-3975},
	url = {https://www.sciencedirect.com/science/article/pii/0304397577900561},
	doi = {10.1016/0304-3975(77)90056-1},
	abstract = {Closed semi-rings and the closure of matrices over closed semi-rings are defined and studied. Closed semi-rings are structures weaker than the structures studied by Conway [3] and Aho, Hopcroft and Ullman [1]. Examples of closed semi-rings and closure operations are given, including the case of semi-rings on which the closure of an element is not always defined. Two algorithms are proved to compute the closure of a matrix over any closed semi-ring; the first one based on Gauss–Jordan elimination is a generalization of algorithms by Warshall, Floyd and Kleene; the second one based on Gauss elimination has been studied by Tarjan [11, 12], from the complexity point of view in a slightly different framework. Simple semi-rings, where the closure operation for elements is trivial, are defined and it is shown that the closure of an n × n-matrix over a simple semi-ring is the sum of its powers of degree less than n. Dijkstra semi-rings are defined and it is shown that the rows of the closure of a matrix over a Dijkstra semi-ring, can be computed by a generalized version of Dijkstra's algorithm.},
	language = {en},
	number = {1},
	urldate = {2023-03-02},
	journal = {Theoretical Computer Science},
	author = {Lehmann, Daniel J.},
	month = feb,
	year = {1977},
	pages = {59--76},
}

@article{dolan_fun_2013,
	title = {Fun with semirings: a functional pearl on the abuse of linear algebra},
	volume = {48},
	issn = {0362-1340},
	shorttitle = {Fun with semirings},
	url = {https://doi.org/10.1145/2544174.2500613},
	doi = {10.1145/2544174.2500613},
	abstract = {Describing a problem using classical linear algebra is a very well-known problem-solving technique. If your question can be formulated as a question about real or complex matrices, then the answer can often be found by standard techniques. It's less well-known that very similar techniques still apply where instead of real or complex numbers we have a closed semiring, which is a structure with some analogue of addition and multiplication that need not support subtraction or division. We define a typeclass in Haskell for describing closed semirings, and implement a few functions for manipulating matrices and polynomials over them. We then show how these functions can be used to calculate transitive closures, find shortest or longest or widest paths in a graph, analyse the data flow of imperative programs, optimally pack knapsacks, and perform discrete event simulations, all by just providing an appropriate underlying closed semiring.},
	number = {9},
	urldate = {2023-03-01},
	journal = {ACM SIGPLAN Notices},
	author = {Dolan, Stephen},
	month = sep,
	year = {2013},
	keywords = {closed semirings, linear systems, shortest paths, transitive closure},
	pages = {101--110},
}

@article{main_free_1985,
	title = {Free semiring-representations and nondeterminism},
	volume = {30},
	issn = {0022-0000},
	url = {https://www.sciencedirect.com/science/article/pii/0022000085900492},
	doi = {10.1016/0022-0000(85)90049-2},
	abstract = {Semirings provide a simple abstract model of the syntax for a nondeterministic programming language. Each element of a semiring is a nondeterministic program segment, and the semiring operations (+ and ⊎) correspond to nondeterministic or and program composition. This is analogous to using an algebraic theory for the abstract syntax of a deterministic language. In the case of algebraic theories, an algebra provides the semantics, and free algebras (which always exist) are particularly important. For a semiring, semantics is provided by a representation as a system of relations. This paper examines the question of when free representations exist. Unlike free algebras, free representations do not always exist. It is shown that a semiring has free representations generated by arbitrary sets of variables iff it has a free representation generated by a single variable. Examples of semirings are given that do not have free representations. However, for an important class of semirings, free representations are always available. This class consists of semirings which arise when nondeterminism is freely added to a deterministic programming language.},
	language = {en},
	number = {3},
	urldate = {2023-03-01},
	journal = {Journal of Computer and System Sciences},
	author = {Main, Michael G. and Benson, David B.},
	month = jun,
	year = {1985},
	pages = {318--328},
}

@inproceedings{king_structuring_1995,
	address = {San Francisco, California, United States},
	title = {Structuring depth-first search algorithms in {Haskell}},
	isbn = {978-0-89791-692-9},
	url = {http://portal.acm.org/citation.cfm?doid=199448.199530},
	doi = {10.1145/199448.199530},
	abstract = {Depth-first search is the key to a wide variety of graph algorithms. In this paper we express depth- rst search in a lazy functional language, obtaining a linear-time implementation. Unlike traditional imperative presentations, we use the structuring methods of functional languages to construct algorithms from individual reusable components. This style of algorithm construction turns out to be quite amenable to formal proof, which we exemplify through a calculationalstyle proof of a far from obvious strongly-connected components algorithm.},
	language = {en},
	urldate = {2023-02-28},
	booktitle = {Proceedings of the 22nd {ACM} {SIGPLAN}-{SIGACT} symposium on {Principles} of programming languages  - {POPL} '95},
	publisher = {ACM Press},
	author = {King, David J. and Launchbury, John},
	year = {1995},
	pages = {344--354},
}

@article{mokhov_united_2022,
	title = {United {Monoids}: {Finding} {Simplicial} {Sets} and {Labelled} {Algebraic} {Graphs} in {Trees}},
	volume = {6},
	issn = {2473-7321},
	shorttitle = {United {Monoids}},
	url = {http://arxiv.org/abs/2202.09230},
	doi = {10.22152/programming-journal.org/2022/6/12},
	abstract = {Graphs and various graph-like combinatorial structures, such as preorders and hypergraphs, are ubiquitous in programming. This paper focuses on representing graphs in a purely functional programming language like Haskell. There are several existing approaches; one of the most recently developed ones is the "algebraic graphs" approach (2017). It uses an algebraic data type to represent graphs and has attracted users, including from industry, due to its emphasis on equational reasoning and making a common class of bugs impossible by eliminating internal invariants. The previous formulation of algebraic graphs did not support edge labels, which was a serious practical limitation. In this paper, we redesign the main algebraic data type and remove this limitation. We follow a fairly standard approach of parameterising a data structure with a semiring of edge labels. The new formulation is both more general and simpler: the two operations for composing graphs used in the previous work can now be obtained from a single operation by fixing the semiring parameter to zero and one, respectively. By instantiating the new data type with different semirings, and working out laws for interpreting the resulting expression trees, we discover an unusual algebraic structure, which we call "united monoids", that is, a pair of monoids whose unit elements coincide. We believe that it is worth studying united monoids in their full generality, going beyond the graphs which prompted their discovery. To that end, we characterise united monoids with a minimal set of axioms, prove a few basic theorems, and discuss several notable examples. We validate the presented approach by implementing it in the open-source *algebraic-graphs* library. Our theoretical contributions are supported by proofs that are included in the paper and have also been machine-checked in Agda. By extending algebraic graphs with support for edge labels, we make them suitable for a much larger class of possible applications. By studying united monoids, we provide a theoretical foundation for further research in this area.},
	number = {3},
	urldate = {2023-02-28},
	journal = {The Art, Science, and Engineering of Programming},
	author = {Mokhov, Andrey},
	month = feb,
	year = {2022},
	note = {arXiv:2202.09230 [cs]},
	keywords = {Computer Science - Programming Languages},
	pages = {12},
}

@article{jun_ideal_2004,
	title = {Ideal {Theory} of {Subtraction} {Algebras}},
	abstract = {The notion of ideals in subtraction algebras is considered. Characterizations of ideals are given.},
	language = {en},
	journal = {Scientiae Mathematicae Japonicae Online},
	author = {Jun, Young Bae and Kim, Hee Sik and Roh, Eun Hwan},
	year = {2004},
	pages = {397--402},
}

@article{schein_difference_1992,
	title = {Difference semigroups},
	volume = {20},
	issn = {0092-7872},
	url = {https://doi.org/10.1080/00927879208824453},
	doi = {10.1080/00927879208824453},
	number = {8},
	urldate = {2023-02-27},
	journal = {Communications in Algebra},
	author = {Schein, Boris M.},
	month = jan,
	year = {1992},
	note = {Publisher: Taylor \& Francis
\_eprint: https://doi.org/10.1080/00927879208824453},
	pages = {2153--2169},
}

@book{mac_lane_categories_1998,
	address = {New York, NY, USA},
	title = {Categories for the {Working} {Mathematician}},
	isbn = {978-1-4757-4721-8},
	url = {http://ebookcentral.proquest.com/lib/oxford/detail.action?docID=3086175},
	abstract = {Categories for the Working Mathematician provides an array of general ideas useful in a wide variety of fields. Starting from the foundations, this book illuminates the concepts of category, functor, natural transformation, and duality. The book then turns to adjoint functors, which provide a description of universal constructions, an analysis of the representations of functors by sets of morphisms, and a means of manipulating direct and inverse limits. These categorical concepts are extensively illustrated in the remaining chapters, which include many applications of the basic existence theorem for adjoint functors. The categories of algebraic systems are constructed from certain adjoint-like data and characterized by Beck's theorem. After considering a variety of applications, the book continues with the construction and exploitation of Kan extensions. This second edition includes a number of revisions and additions, including two new chapters on topics of active interest. One is on symmetric monoidal categories and braided monoidal categories and the coherence theorems for them. The second describes 2-categories and the higher dimensional categories which have recently come into prominence. The bibliography has also been expanded to cover some of the many other recent advances concerning categories.},
	urldate = {2023-02-23},
	publisher = {Springer New York},
	author = {Mac Lane, Saunders},
	year = {1998},
	keywords = {Categories (Mathematics)},
}

@article{cazanescu_classes_1994,
	title = {Classes of finite relations as initial abstract data types – {II}},
	volume = {126},
	issn = {0012-365X},
	url = {https://www.sciencedirect.com/science/article/pii/0012365X94902526},
	doi = {10.1016/0012-365X(94)90252-6},
	abstract = {In this second part we extend the presentations in the first part to classes of multirelations, give presentations for algebraic and matrix theories in terms of (symmetric) strict monoidal categories, and give some weaker systems of axioms to present the classes of relations studied in the first part. (By ‘weaker systems of axioms’ we mean the following: these systems of axioms give bigger varieties in which the corresponding classes of relations are still initial algebras.)},
	language = {en},
	number = {1},
	urldate = {2023-02-23},
	journal = {Discrete Mathematics},
	author = {Cǎzǎnescu, Virgil-Emil and Ştefǎnescu, Gheorghe},
	month = mar,
	year = {1994},
	pages = {47--65},
}

@article{xu_making_2023,
	title = {Making a {Type} {Difference}: {Subtraction} on {Intersection} {Types} as {Generalized} {Record} {Operations}},
	volume = {7},
	shorttitle = {Making a {Type} {Difference}},
	url = {https://doi.org/10.1145/3571224},
	doi = {10.1145/3571224},
	abstract = {In programming languages with records, objects, or traits, it is common to have operators that allow dropping, updating or renaming some components. These operators are useful for programmers to explicitly deal with conflicts and override or update some components. While such operators have been studied for record types, little work has been done to generalize and study their theory for other types. This paper shows that, given subtyping and disjointness relations, we can specify and derive algorithmic implementations for a general type difference operator that works for other types, including function types, record types and intersection types. When defined in this way, the type difference algebra has many desired properties that are expected from a subtraction operator. Together with a generic merge operator, using type difference we can generalize many operations on records formalized in the literature. To illustrate the usefulness of type difference we create an intermediate calculus with a rich set of operators on expressions of arbitrary type, and demonstrate applications of these operators in CP, a prototype language for Compositional Programming. The semantics of the calculus is given by elaborating into a calculus with disjoint intersection types and a merge operator. We have implemented type difference and all the operators in the CP language. Moreover, all the calculi and related proofs are mechanically formalized in the Coq theorem prover.},
	number = {POPL},
	urldate = {2023-02-15},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Xu, Han and Huang, Xuejing and Oliveira, Bruno C. d. S.},
	month = jan,
	year = {2023},
	keywords = {functional languages, object oriented languages, type systems},
	pages = {31:893--31:920},
}

@incollection{van_rijsbergen_boom_1994,
	address = {London},
	title = {The {Boom} {Hierarchy}},
	isbn = {978-3-540-19879-6 978-1-4471-3236-3},
	url = {http://link.springer.com/10.1007/978-1-4471-3236-3_1},
	abstract = {The Boom Hierarchy is the family of data structures tree, list, bag, set. By combining their properties in other ways, more data structures can be made, like mobiles. The paper de nes the data structures of this extended Boom Hierarchy and shows how the functions reduce, map, and lter are applied to them.},
	language = {en},
	urldate = {2023-02-14},
	booktitle = {Functional {Programming}, {Glasgow} 1993},
	publisher = {Springer London},
	author = {Bunkenburg, Alexander},
	editor = {van Rijsbergen, C. J. and O’Donnell, John T. and Hammond, Kevin},
	year = {1994},
	doi = {10.1007/978-1-4471-3236-3_1},
	note = {Series Title: Workshops in Computing},
	pages = {1--8},
}

@incollection{gibbons_initial-algebra_2005,
	address = {Berlin, Heidelberg},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {An initial-algebra approach to directed acyclic graphs},
	isbn = {978-3-540-60117-3},
	abstract = {The initial-algebra approach to modelling datatypes consists of giving constructors for building larger objects of that type from smaller ones, and laws identifying different ways of constructing the same object. The recursive decomposition of objects of the datatype leads directly to a recursive pattern of computation on those objects, which is very helpful for both functional and parallel programming.
We show how to model a particular kind of directed acyclic graph using this initial-algebra approach.},
	language = {eng},
	booktitle = {Mathematics of {Program} {Construction}},
	publisher = {Springer Berlin Heidelberg},
	author = {Gibbons, Jeremy},
	year = {2005},
	doi = {10.1007/3-540-60117-1_16},
	note = {ISSN: 0302-9743},
	keywords = {Bird-Meertens Formalism, Graphs, catamorphisms, data types, initial algebras, program derivation},
	pages = {282--303},
}

@inproceedings{gibbons_folding_2014,
	address = {Gothenburg Sweden},
	title = {Folding domain-specific languages: deep and shallow embeddings (functional {Pearl})},
	isbn = {978-1-4503-2873-9},
	shorttitle = {Folding domain-specific languages},
	url = {https://dl.acm.org/doi/10.1145/2628136.2628138},
	doi = {10.1145/2628136.2628138},
	abstract = {A domain-speciﬁc language can be implemented by embedding within a general-purpose host language. This embedding may be deep or shallow, depending on whether terms in the language construct syntactic or semantic representations. The deep and shallow styles are closely related, and intimately connected to folds; in this paper, we explore that connection.},
	language = {en},
	urldate = {2023-01-09},
	booktitle = {Proceedings of the 19th {ACM} {SIGPLAN} international conference on {Functional} programming},
	publisher = {ACM},
	author = {Gibbons, Jeremy and Wu, Nicolas},
	month = aug,
	year = {2014},
	pages = {339--347},
}

@article{mokhov_algebra_2014,
	title = {Algebra of {Parameterised} {Graphs}},
	volume = {13},
	issn = {1539-9087},
	doi = {10.1145/2627351},
	abstract = {One of the difficulties in designing modern hardware systems is the necessity for comprehending and dealing with a very large number of system configurations, operational modes, and behavioural scenarios. It is often infeasible to consider and specify each individual mode explicitly, and one needs methodologies and tools to exploit similarities between the individual modes and work with groups of modes rather than individual ones. The modes and groups of modes have to be managed in a compositional way: the specification of the system should be composed from specifications of its blocks. This includes both structural and behavioural composition. Furthermore, one should be able to transform and optimise the specifications in a formal way.
In this article, we propose a new formalism, called parameterised graphs . It extends the existing conditional partial order graphs (CPOGs) formalism in several ways. First, it deals with general graphs rather than just partial orders. Moreover, it is fully compositional. To achieve this, we introduce an algebra of parameterised graphs by specifying the equivalence relation by a set of axioms, which is proved to be sound, minimal, and complete. This allows one to manipulate the specifications as algebraic expressions using the rules of this algebra. We demonstrate the usefulness of the developed formalism on several case studies coming from the area of microelectronics design.},
	language = {eng},
	number = {4s},
	journal = {ACM transactions on embedded computing systems},
	author = {Mokhov, Andrey and Khomenko, Victor},
	year = {2014},
	note = {Publisher: ACM},
	keywords = {Algebra, Axioms, Behavioural, Equivalence, Formalism, Graphs, Hardware, Parameterised graphs, Specifications, conditional partial-order graphs, instruction set architecture, microelectronics, switching networks, synthesis, transistor networks},
	pages = {1--22},
}

@article{milewski_category_2014,
	title = {Category {Theory} for {Programmers}},
	abstract = {Bartosz Milewski's 'Category Theory for Programmers' unofficial PDF and LaTeX source},
	language = {en},
	author = {Milewski, Bartosz},
	year = {2014},
	pages = {510},
}

@misc{safronov_category_2019,
	title = {Category {Theory} {Notes}},
	abstract = {Notes for University of Oxford course C2.7: Category Theory},
	language = {en},
	author = {Safronov, Pavel},
	year = {2019},
	keywords = {category theory, notes},
}

@inproceedings{mokhov_algebraic_2017,
	address = {New York, NY, USA},
	series = {Haskell 2017},
	title = {Algebraic graphs with class (functional pearl)},
	isbn = {978-1-4503-5182-9},
	url = {https://ezproxy-prd.bodleian.ox.ac.uk:2102/10.1145/3122955.3122956},
	doi = {10.1145/3122955.3122956},
	abstract = {The paper presents a minimalistic and elegant approach to working with graphs in Haskell. It is built on a rigorous mathematical foundation --- an algebra of graphs --- that allows us to apply equational reasoning for proving the correctness of graph transformation algorithms. Algebraic graphs let us avoid partial functions typically caused by `malformed graphs' that contain an edge referring to a non-existent vertex. This helps to liberate APIs of existing graph libraries from partial functions. The algebra of graphs can represent directed, undirected, reflexive and transitive graphs, as well as hypergraphs, by appropriately choosing the set of underlying axioms. The flexibility of the approach is demonstrated by developing a library for constructing and transforming polymorphic graphs.},
	urldate = {2022-11-29},
	booktitle = {Proceedings of the 10th {ACM} {SIGPLAN} {International} {Symposium} on {Haskell}},
	publisher = {Association for Computing Machinery},
	author = {Mokhov, Andrey},
	month = sep,
	year = {2017},
	keywords = {Haskell, algebra, graph theory},
	pages = {2--13},
}

@article{erwig_inductive_2001,
	title = {Inductive graphs and functional graph algorithms},
	volume = {11},
	issn = {1469-7653, 0956-7968},
	url = {https://ezproxy-prd.bodleian.ox.ac.uk:2117/core/journals/journal-of-functional-programming/article/inductive-graphs-and-functional-graph-algorithms/2210F7C31A34EA4CF5008ED9E7B4EF62},
	doi = {10.1017/S0956796801004075},
	abstract = {We propose a new style of writing graph algorithms in functional languages which is based on an alternative view of graphs as inductively defined data types. We show how this graph model can be implemented efficiently, and then we demonstrate how graph algorithms can be succinctly given by recursive function definitions based on the inductive graph view. We also regard this as a contribution to the teaching of algorithms and data structures in functional languages since we can use the functional-style graph algorithms instead of the imperative algorithms that are dominant today.},
	language = {en},
	number = {5},
	urldate = {2022-11-28},
	journal = {Journal of Functional Programming},
	author = {Erwig, Martin},
	month = sep,
	year = {2001},
	note = {Publisher: Cambridge University Press},
	pages = {467--492},
}

@inproceedings{hoogendijk_when_1997,
	title = {When {Do} {Datatypes} {Commute}?},
	url = {http://undefined/chapter/10.1007/BFb0026992},
	doi = {10.1007/BFb0026992},
	abstract = {Polytypic programs are programs that are parameterised by type constructors (like List), unlike polymorphic programs which are parameterised by types (like Int). In this paper we formulate precisely the polytypic programming problem of “commuting” two...},
	language = {en},
	urldate = {2022-11-22},
	booktitle = {Category {Theory} and {Computer} {Science}},
	publisher = {Springer, Berlin, Heidelberg},
	author = {Hoogendijk, Paul and Backhouse, Roland},
	year = {1997},
	pages = {242--260},
}

@article{bird_generic_1996,
	title = {Generic functional programming with types and relations},
	volume = {6},
	issn = {1469-7653, 0956-7968},
	url = {https://ezproxy-prd.bodleian.ox.ac.uk:2117/core/journals/journal-of-functional-programming/article/generic-functional-programming-with-types-and-relations/67C5B097533659132953E973698B81A6},
	doi = {10.1017/S0956796800001556},
	abstract = {A generic functional program is one which is parameterised by datatype. By installing specific choices, for example lists or trees, different programs are obtained that are, nevertheless, abstractly the same. The purpose of this paper is to explore the possibility of deriving generic programs. Part of the theory of lists that deals with segments is recast as a theory about ‘segments’ in a wide class of datatypes, and then used to pose and solve a generic version of a well-known problem.},
	language = {en},
	number = {1},
	urldate = {2022-11-21},
	journal = {Journal of Functional Programming},
	author = {Bird, Richard and Moor, Oege De and Hoogendijk, Paul},
	month = jan,
	year = {1996},
	note = {Publisher: Cambridge University Press},
	pages = {1--28},
}

@book{gibbons_accumulating_2013,
	title = {Accumulating {Attributes} (for {Doaitse} {Swierstra}‚ on his retirement)},
	abstract = {Doaitse has always been enthusiastic about attribute grammars, seeing them even where most people don't. While I was writing up my DPhil thesis, he explained to me where they were in that too. This paper is by way of belated thanks for that perspective - and as a more general rendering of the observation, with the benefit of hindsight and twenty years of progress.},
	author = {Gibbons, Jeremy},
	year = {2013},
}

@article{gibbons_generic_2000,
	title = {Generic downwards accumulations},
	volume = {37},
	issn = {01676423},
	url = {https://linkinghub.elsevier.com/retrieve/pii/S0167642399000222},
	doi = {10.1016/S0167-6423(99)00022-2},
	abstract = {A downwards accumulation is a higher-order operation that distributes information downwards through a data structure, from the root towards the leaves. The concept was originally introduced in an ad hoc way for just a couple of kinds of tree. We generalize the concept to an arbitrary regular datatype; the resulting deÿnition is co-inductive. c 2000 Elsevier Science B.V. All rights reserved.},
	language = {en},
	number = {1-3},
	urldate = {2022-11-15},
	journal = {Science of Computer Programming},
	author = {Gibbons, Jeremy},
	month = may,
	year = {2000},
	pages = {37--65},
}

@inproceedings{gibbons_polytypic_1998,
	title = {Polytypic downwards accumulations},
	url = {http://undefined/chapter/10.1007/BFb0054292},
	doi = {10.1007/BFb0054292},
	abstract = {A downwards accumulation is a higher-order operation that distributes information downwards through a data structure, from the root towards the leaves. The concept was originally introduced in an ad hoc way for just a couple of kinds of tree. We generalize the...},
	language = {en},
	urldate = {2022-11-15},
	booktitle = {Mathematics of {Program} {Construction}},
	publisher = {Springer, Berlin, Heidelberg},
	author = {Gibbons, Jeremy},
	year = {1998},
	pages = {207--233},
}

@inproceedings{gibbons_upwards_1993,
	title = {Upwards and downwards accumulations on trees},
	url = {http://undefined/chapter/10.1007/3-540-56625-2_11},
	doi = {10.1007/3-540-56625-2_11},
	abstract = {An accumulation is a higher-order operation over structured objects of some type; it leaves the shape of an object unchanged, but replaces each element of that object with some accumulated information about the other elements. Upwards and downwards accumulations on...},
	language = {en},
	urldate = {2022-11-15},
	booktitle = {Mathematics of {Program} {Construction}},
	publisher = {Springer, Berlin, Heidelberg},
	author = {Gibbons, Jeremy},
	year = {1993},
	pages = {122--138},
}

@article{lampropoulos_coverage_2019,
	title = {Coverage guided, property based testing},
	volume = {3},
	issn = {2475-1421},
	doi = {10.1145/3360607},
	abstract = {Property-based random testing, exemplified by frameworks such as Haskell's QuickCheck, works by testing an executable predicate (a property) on a stream of randomly generated inputs. Property testing works very well in many cases, but not always. Some properties are conditioned on the input satisfying demanding semantic invariants that are not consequences of its syntactic structure---e.g., that an input list must be sorted or have no duplicates. Most randomly generated inputs fail to satisfy properties with such sparse preconditions, and so are simply discarded. As a result, much of the target system may go untested.
We address this issue with a novel technique called coverage guided, property based testing (CGPT). Our approach is inspired by the related area of coverage guided fuzzing, exemplified by tools like AFL. Rather than just generating a fresh random input at each iteration, CGPT can also produce new inputs by mutating previous ones using type-aware, generic mutator operators. The target program is instrumented to track which control flow branches are executed during a run and inputs whose runs expand control-flow coverage are retained for future mutations. This means that, when sparse conditions in the target are satisfied and new coverage is observed, the input that triggered them will be retained and used as a springboard to go further.
We have implemented CGPT as an extension to the QuickChick property testing tool for Coq programs; we call our implementation FuzzChick. We evaluate FuzzChick on two Coq developments for abstract machines that aim to enforce flavors of noninterference, which has a (very) sparse precondition. We systematically inject bugs in the machines' checking rules and use FuzzChick to look for counterexamples to the claim that they satisfy a standard noninterference property. We find that vanilla QuickChick almost always fails to find any bugs after a long period of time, as does an earlier proposal for combining property testing and fuzzing. In contrast, FuzzChick often finds them within seconds to minutes. Moreover, FuzzChick is almost fully automatic; although highly tuned, hand-written generators can find the bugs faster, they require substantial amounts of insight and manual effort.},
	language = {eng},
	number = {OOPSLA},
	journal = {Proceedings of ACM on programming languages},
	author = {Lampropoulos, Leonidas and Hicks, Michael and Pierce, Benjamin C.},
	year = {2019},
	note = {Publisher: ACM},
	keywords = {AFL, FuzzChick, QuickChick, coverage, fuzz testing, property-based testing, random testing},
	pages = {1--29},
}

@article{kim_distance_2020,
	title = {Distance metrics for ranked evolutionary trees},
	volume = {117},
	url = {https://www.pnas.org/doi/10.1073/pnas.1922851117},
	doi = {10.1073/pnas.1922851117},
	abstract = {Genealogical tree modeling is essential for estimating evolutionary parameters in population genetics and phylogenetics. Recent mathematical results concerning ranked genealogies without leaf labels unlock opportunities in the analysis of evolutionary trees. In particular, comparisons between ranked genealogies facilitate the study of evolutionary processes of different organisms sampled at multiple time periods. We propose metrics on ranked tree shapes and ranked genealogies for lineages isochronously and heterochronously sampled. Our proposed tree metrics make it possible to conduct statistical analyses of ranked tree shapes and timed ranked tree shapes or ranked genealogies. Such analyses allow us to assess differences in tree distributions, quantify estimation uncertainty, and summarize tree distributions. We show the utility of our metrics via simulations and an application in infectious diseases.},
	number = {46},
	urldate = {2022-11-10},
	journal = {Proceedings of the National Academy of Sciences},
	author = {Kim, Jaehee and Rosenberg, Noah A. and Palacios, Julia A.},
	month = nov,
	year = {2020},
	note = {Publisher: Proceedings of the National Academy of Sciences},
	pages = {28876--28886},
}

@inproceedings{reddy_quickly_2020,
	title = {Quickly {Generating} {Diverse} {Valid} {Test} {Inputs} with {Reinforcement} {Learning}},
	abstract = {Property-based testing is a popular approach for validating the logic of a program. An effective property-based test quickly generates many diverse valid test inputs and runs them through a parameterized test driver. However, when the test driver requires strict validity constraints on the inputs, completely random input generation fails to generate enough valid inputs. Existing approaches to solving this problem rely on whitebox or greybox information collected by instrumenting the input generator and/or test driver. However, collecting such information reduces the speed at which tests can be executed. In this paper, we propose and study a black-box approach for generating valid test inputs. We first formalize the problem of guiding random input generators towards producing a diverse set of valid inputs. This formalization highlights the role of a guide which governs the space of choices within a random input generator. We then propose a solution based on reinforcement learning (RL), using a tabular, on-policy RL approach to guide the generator. We evaluate this approach, RLCheck, against pure random input generation as well as a state-of-the-art greybox evolutionary algorithm, on four real-world benchmarks. We find that in the same time budget, RLCheck generates an order of magnitude more diverse valid inputs than the baselines.},
	booktitle = {2020 {IEEE}/{ACM} 42nd {International} {Conference} on {Software} {Engineering} ({ICSE})},
	author = {Reddy, Sameer and Lemieux, Caroline and Padhye, Rohan and Sen, Koushik},
	month = oct,
	year = {2020},
	note = {ISSN: 1558-1225},
	keywords = {Benchmark testing, Evolutionary computation, Generators, Instruments, Monte Carlo methods, Reinforcement learning, Software engineering},
	pages = {1410--1421},
}

@inproceedings{robert_taf_2021,
	title = {{TAF}: a {Tool} for {Diverse} and {Constrained} {Test} {Case} {Generation}},
	isbn = {978-1-66545-813-9},
	shorttitle = {{TAF}},
	url = {https://ieeexplore.ieee.org/document/9724803},
	doi = {10.1109/QRS54544.2021.00042},
	abstract = {The generation of test cases may have to accommodate size-varying data structures and semantic constraints between the data elements. This often requires the development of custom generators. In this paper, we introduce a novel generic tool to generate constrained and diverse test cases from a data model. First, the user defines the model using an XML-based domain-specific language. Then TAF generates diverse test cases by combining random sampling with the use of an SMT solver. The capabilities of the tool are demonstrated by four examples of models coming from various application domains: virtual crop fields for testing an agriculture robot, bitmap images with a graduated background, a population of taxpayers in a tax management system, and tree structures of diverse sizes and heights. We show how TAF performs in terms of data diversity and execution time. We also provide some comparison results with an UML-based tool using SMT solving.},
	language = {eng},
	urldate = {2022-11-10},
	publisher = {IEEE},
	author = {Robert, Clement and Guiochet, Jeremie and Waeselynck, Helene and Sartori, Luca Vittorio},
	year = {2021},
	note = {Book Title: 2021 IEEE 21st International Conference on Software Quality, Reliability and Security (QRS)
ISSN: 2693-9177},
	keywords = {Data models, Data structures, Diversity reception, Test pattern generators, Three-dimensional displays, Unified modeling language, Usability, autonomous robots, fuzzing, simulation, test, test input generation},
	pages = {311--321},
}

@incollection{westphal_framework_2021,
	address = {Cham},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {A {Framework} for {Generating} {Diverse} {Haskell}-{I}/{O} {Exercise} {Tasks}},
	isbn = {978-3-030-75332-0},
	abstract = {We present the design of a framework to describe parametrized exercise tasks on Haskell-I/O programming. Parametrized tasks can be instantiated randomly to quickly generate different instances of a task. Such automatic task generation is useful in many different ways. Manual task creation can be a time-consuming process, so formulating a task design once and then automatically generating different variations can save valuable time for the educator. The descriptions of tasks also serve as easy to understand documentation and can be reused in new task designs. On the student’s side automatic task generation, together with an automated assessment system, enables practicing on as many fresh exercise tasks as needed. Students can also each be given a slightly different version of tasks, reducing issues regarding plagiarism arising naturally in an e-learning environment. Our task generation is centered around a specification language for I/O behavior we developed in earlier work. The task generation framework, an embedded domain specific language in Haskell, provides powerful primitives for the creation of various artifacts from specifications, including program code. We do not go into detail on the technical realization of these primitives. Our focus is on showcasing how such artifacts can be used as an alternative to the verbal description of requirements for different types of programming exercise tasks. By doing so, we are able to automatically generate a diverse range of task designs.},
	language = {eng},
	booktitle = {Functional and {Constraint} {Logic} {Programming}},
	publisher = {Springer International Publishing},
	author = {Westphal, Oliver},
	year = {2021},
	doi = {10.1007/978-3-030-75333-7_6},
	note = {ISSN: 0302-9743},
	pages = {97--114},
}

@inproceedings{mcbride_clowns_2008,
	address = {New York, NY, USA},
	series = {{POPL} '08},
	title = {Clowns to the left of me, jokers to the right (pearl): dissecting data structures},
	isbn = {978-1-59593-689-9},
	shorttitle = {Clowns to the left of me, jokers to the right (pearl)},
	url = {https://ezproxy-prd.bodleian.ox.ac.uk:2102/10.1145/1328438.1328474},
	doi = {10.1145/1328438.1328474},
	abstract = {This paper introduces a small but useful generalisation to the 'derivative' operation on datatypes underlying Huet's notion of 'zipper', giving a concrete representation to one-hole contexts in data which is undergoing transformation. This operator, 'dissection', turns a container-like functor into a bifunctor representing a one-hole context in which elements to the left of the hole are distinguished in type from elements to its right. I present dissection here as a generic program, albeit for polynomial functors only. The notion is certainly applicable more widely, but here I prefer to concentrate on its diverse applications. For a start, map-like operations over the functor and fold-like operations over the recursive data structure it induces can be expressed by tail recursion alone. Further, the derivative is readily recovered from the dissection. Indeed, it is the dissection structure which delivers Huet's operations for navigating zippers. The original motivation for dissection was to define 'division', capturing the notion of leftmost hole, canonically distinguishing values with no elements from those with at least one. Division gives rise to an isomorphism corresponding to the remainder theorem in algebra. By way of a larger example, division and dissection are exploited to give a relatively efficient generic algorithm for abstracting all occurrences of one term from another in a first-order syntax. The source code for the paper is available online and compiles with recent extensions to the Glasgow Haskell Compiler.},
	urldate = {2022-11-09},
	booktitle = {Proceedings of the 35th annual {ACM} {SIGPLAN}-{SIGACT} symposium on {Principles} of programming languages},
	publisher = {Association for Computing Machinery},
	author = {McBride, Conor},
	month = jan,
	year = {2008},
	keywords = {datatype, differentiation, dissection, division, generic programming, iteration, polynomial, stack, tail recursion, traversal, zipper},
	pages = {287--295},
}

@article{kuraj_programming_2015,
	title = {Programming with enumerable sets of structures},
	volume = {50},
	issn = {0362-1340},
	doi = {10.1145/2858965.2814323},
	abstract = {We present an efficient, modular, and feature-rich framework for automated generation and validation of complex structures, suitable for tasks that explore a large space of structured values. Our framework is capable of exhaustive, incremental, parallel, and memoized enumeration from not only finite but also infinite domains, while providing fine-grained control over the process. Furthermore, the framework efficiently supports the inverse of enumeration (checking whether a structure can be generated and fast-forwarding to this structure to continue the enumeration) and lazy enumeration (achieving exhaustive testing without generating all structures). The foundation of efficient enumeration lies in both direct access to encoded structures, achieved with well-known and new pairing functions, and dependent enumeration, which embeds constraints into the enumeration to avoid backtracking. Our framework defines an algebra of enumerators, with combinators for their composition that preserve exhaustiveness and efficiency. We have implemented our framework as a domain-specific language in Scala. Our experiments demonstrate better performance and shorter specifications by up to a few orders of magnitude compared to existing approaches.},
	language = {eng},
	number = {10},
	journal = {SIGPLAN notices},
	author = {Kuraj, Ivan and Kuncak, Viktor and Jackson, Daniel},
	year = {2015},
	note = {Publisher: ACM},
	keywords = {DSL, Dependent enumeration, SciFe, algebra, data generation, exhaustive testing, invariant, lazy evaluation, pairing function, program inversion, random testing},
	pages = {37--56},
}

@inproceedings{jones_comprehensive_2007,
	series = {Haskell '07},
	title = {Comprehensive comprehensions},
	isbn = {978-1-59593-674-5},
	doi = {10.1145/1291201.1291209},
	abstract = {We propose an extension to list comprehensions that makes it easy to express the kind of queries one would write in SQL using ORDER BY, GROUP BY, and LIMIT. Our extension adds expressive power to comprehensions, and generalises the SQL constructs that inspired it. It is easy to implement, using simple desugaring rules.},
	language = {eng},
	publisher = {ACM},
	author = {Jones, Simon and Wadler, Philip},
	year = {2007},
	note = {Book Title: Haskell: Proceedings of the ACM SIGPLAN workshop on Haskell workshop; 30-30 Sept. 2007},
	keywords = {SQL, aggregate, list comprehension, query},
	pages = {61--72},
}

@inproceedings{gibbons_free_2016,
	title = {Free delivery (functional pearl)},
	doi = {10.1145/2976002.2976005},
	abstract = {Remote procedure calls are computationally expensive, because network round-trips take several orders of magnitude longer than local interactions. One common technique for amortizing this cost is to batch together multiple independent requests into one compound request. Batching requests amounts to serializing the abstract syntax tree of a small program, in order to transmit it and run it remotely. The standard representation for abstract syntax is to use free monads; we show that free applicative functors are actually a better choice of representation for this scenario.},
	publisher = {Association for Computing Machinery},
	author = {Gibbons, Jeremy},
	year = {2016},
	note = {Book Title: Free delivery (functional pearl)},
}

@article{marlow_desugaring_2018,
	title = {Desugaring {Haskell}'s do-notation into applicative operations},
	volume = {51},
	issn = {0362-1340},
	doi = {10.1145/3241625.2976007},
	abstract = {Monads have taken the world by storm, and are supported by do-notation (at least in Haskell). Programmers are increasingly waking up to the usefulness and ubiquity of Applicatives, but they have so far been hampered by the absence of supporting notation. In this paper we show how to re-use the very same do-notation to work for Applicatives as well, providing efficiency benefits for some types that are both Monad and Applicative, and syntactic convenience for those that are merely Applicative. The result is fully implemented as an optional extension in GHC, and is in use at Facebook to make it easy to write highly-parallel queries in a distributed system.},
	language = {eng},
	number = {12},
	journal = {SIGPLAN notices},
	author = {Marlow, Simon and Peyton Jones, Simon and Kmett, Edward and Mokhov, Andrey},
	year = {2018},
	note = {Publisher: ACM},
	keywords = {Applicative Functors, Monads, concurrency, parallelism},
	pages = {92--104},
}

@article{henglein_generic_2010,
	title = {Generic multiset programming with discrimination-based joins and symbolic {Cartesian} products},
	volume = {23},
	copyright = {2011 Springer Science+Business Media, LLC},
	issn = {1573-0557},
	url = {http://undefined/article/10.1007/s10990-011-9078-8},
	doi = {10.1007/s10990-011-9078-8},
	abstract = {This paper presents GMP, a library for generic, SQL-style programming with multisets. It generalizes the querying core of SQL in a number of ways: Multisets may contain elements of arbitrary first-order data types, including references (pointers), recursive data types and nested multisets; it contains an expressive embedded domain-specific language for specifying user-definable equivalence and ordering relations, extending the built-in equality and inequality predicates; it admits mapping arbitrary functions over multisets, not just projections; it supports user-defined predicates in selections; and it allows user-defined aggregation functions.Most significantly, it avoids many cases of asymptotically inefficient nested iteration through Cartesian products that occur in a straightforward stream-based implementation of multisets. It accomplishes this by employing two novel techniques: symbolic (term) representations of multisets, specifically for Cartesian products, for facilitating dynamic symbolic computation, which intersperses algebraic simplification steps with conventional data processing; and discrimination-based joins, a generic technique for computing equijoins based on equivalence discriminators, as an alternative to hash-based and sort-merge joins.Full source code for GMP in Haskell, which is based on generic top-down discrimination (not included), is included for experimentation. We provide illustrative examples whose performance indicates that GMP, even without requisite algorithm and data structure engineering, is a realistic alternative to SQL even for SQL-expressible queries.},
	language = {en},
	number = {3},
	urldate = {2022-11-08},
	journal = {Higher-Order and Symbolic Computation},
	author = {Henglein, Fritz and Larsen, Ken Friis},
	month = sep,
	year = {2010},
	note = {Company: Springer
Distributor: Springer
Institution: Springer
Label: Springer
Number: 3
Publisher: Springer US},
	pages = {337--370},
}

@article{claessen_quickcheck_2011,
	title = {{QuickCheck}: a lightweight tool for random testing of {Haskell} programs},
	volume = {46},
	issn = {0362-1340},
	shorttitle = {{QuickCheck}},
	url = {https://ezproxy-prd.bodleian.ox.ac.uk:2102/10.1145/1988042.1988046},
	doi = {10.1145/1988042.1988046},
	abstract = {QuickCheck is a tool which aids the Haskell programmer in formulating and testing properties of programs. Properties are discribed as Haskell functions, and can be automatically tested on random input, but it is also possible to define custom test data generators. We present a number of case studies, in which the tool was successfully used, and also point out some pitfalls to avoid. Random testing is especially suitable for functional programs because properties can be stated at a fine grain. When a function is built from separately tested components, then random testing suffuces to obtain good coverage of the definition under test.},
	number = {4},
	urldate = {2022-11-07},
	journal = {ACM SIGPLAN Notices},
	author = {Claessen, Koen and Hughes, John},
	month = may,
	year = {2011},
	keywords = {property-based testing},
	pages = {53--64},
}

@article{noauthor_generatingfunctionology_1990,
	title = {Generatingfunctionology},
	volume = {32},
	issn = {0378-4754},
	doi = {10.1016/0378-4754(90)90171-E},
	language = {eng},
	number = {4},
	journal = {Mathematics and computers in simulation},
	year = {1990},
	pages = {427--},
}

@article{america_solving_1989,
	title = {Solving reflexive domain equations in a category of complete metric spaces},
	volume = {39},
	issn = {0022-0000},
	doi = {10.1016/0022-0000(89)90027-5},
	abstract = {This paper presents a technique by which solutions to reflexive domain equations can be found in a certain category of complete metric spaces. The objects in this category are the (non-empty) metric spaces and the arrows consist of two maps: an isometric embedding and a non-distance-increasing left inverse to it. The solution of the equation is constructed as a fixed point of a functor over this category associated with the equation. The fixed point obtained is the direct limit (colimit) of a convergent tower. This construction works if the functor is
contracting, which roughly amounts to the condition that it maps every embedding to an even denser one. We also present two additional conditions, each of which is sufficient to ensure that the functor has a
unique fixed point (up to isomorphism). Finally, for a large class of functors, including function space constructions, we show that these conditions are satisfied, so that they are guaranteed to have a unique fixed point. The techniques we use are so reminiscent of Banach's fixed-point theorem that we feel justified to speak of a category-theoretic version of it.},
	language = {eng},
	number = {3},
	journal = {Journal of computer and system sciences},
	author = {America, Pierre and Rutten, Jan},
	year = {1989},
	note = {Publisher: Elsevier Inc},
	pages = {343--375},
}

@misc{lalley_branching_2016,
	title = {Branching {Processes}},
	url = {http://galton.uchicago.edu/~lalley/Courses/312/Branching.pdf},
	abstract = {This course will introduce some of the major classes of stochastic processes: Poisson processes, Markov chains, random walks, renewal processes, martingales, and Brownian motion. A substantial part of the course will be devoted to the study of important examples, such as branching processes, queues, birth-and-death chains, and urn models. Students will be expected to have proficiency in elementary probability theory, undergraduate real analysis (especially sequences and series), and matrix algebra. Some familiarity with the theory of Lebesgue measure and integration would be helpful, but is not essential. There will be weekly problem assignments and midterm and final exams.},
	author = {Lalley, Steve},
	year = {2016},
}

@article{new_fair_2017,
	title = {Fair enumeration combinators},
	volume = {27},
	issn = {0956-7968, 1469-7653},
	url = {https://ezproxy-prd.bodleian.ox.ac.uk:2117/core/journals/journal-of-functional-programming/article/fair-enumeration-combinators/CCEC7CBA286B2F792B073586EFCD6F3A},
	doi = {10.1017/S0956796817000107},
	abstract = {Enumerations represented as bijections between the natural numbers and elements of some given type have recently garnered interest in property-based testing because of their efficiency and flexibility. There are, however, many ways of defining these bijections, some of which are better than others. This paper offers a new property of enumeration combinators called fairness that identifies enumeration combinators that are better suited to property-based testing. Intuitively, the result of a fair combinator indexes into its argument enumerations equally when constructing its result. For example, extracting the nth element from our enumeration of three-tuples indexes about into one of the argument enumerators. The paper presents a semantics of enumeration combinators, a theory of fairness, proofs establishing fairness of our new combinators and that some combinations of fair combinators are not fair. We also report on an evaluation of fairness for the purpose of finding bugs in programming-language models. We show that fair enumeration combinators have complementary strengths to an existing, well-tuned ad hoc random generator (better on short time scales and worse on long time scales) and that using unfair combinators is worse across the board.},
	language = {en},
	urldate = {2022-11-07},
	journal = {Journal of Functional Programming},
	author = {New, Max S. and Fetscher, Burke and Findler, Robert Bruce and Mccarthy, Jay},
	year = {2017},
	note = {Publisher: Cambridge University Press},
	pages = {e19},
}

@misc{bronstein_geometric_2021,
	title = {Geometric {Deep} {Learning}: {Grids}, {Groups}, {Graphs}, {Geodesics}, and {Gauges}},
	shorttitle = {Geometric {Deep} {Learning}},
	url = {http://arxiv.org/abs/2104.13478},
	doi = {10.48550/arXiv.2104.13478},
	abstract = {The last decade has witnessed an experimental revolution in data science and machine learning, epitomised by deep learning methods. Indeed, many high-dimensional learning tasks previously thought to be beyond reach -- such as computer vision, playing Go, or protein folding -- are in fact feasible with appropriate computational scale. Remarkably, the essence of deep learning is built from two simple algorithmic principles: first, the notion of representation or feature learning, whereby adapted, often hierarchical, features capture the appropriate notion of regularity for each task, and second, learning by local gradient-descent type methods, typically implemented as backpropagation. While learning generic functions in high dimensions is a cursed estimation problem, most tasks of interest are not generic, and come with essential pre-defined regularities arising from the underlying low-dimensionality and structure of the physical world. This text is concerned with exposing these regularities through unified geometric principles that can be applied throughout a wide spectrum of applications. Such a 'geometric unification' endeavour, in the spirit of Felix Klein's Erlangen Program, serves a dual purpose: on one hand, it provides a common mathematical framework to study the most successful neural network architectures, such as CNNs, RNNs, GNNs, and Transformers. On the other hand, it gives a constructive procedure to incorporate prior physical knowledge into neural architectures and provide principled way to build future architectures yet to be invented.},
	urldate = {2022-11-07},
	publisher = {arXiv},
	author = {Bronstein, Michael M. and Bruna, Joan and Cohen, Taco and Veličković, Petar},
	month = may,
	year = {2021},
	note = {arXiv:2104.13478 [cs, stat]},
	keywords = {Computer Science - Artificial Intelligence, Computer Science - Computational Geometry, Computer Science - Computer Vision and Pattern Recognition, Computer Science - Machine Learning, Statistics - Machine Learning},
}

@book{smith_introduction_2007,
	address = {Cambridge},
	series = {Cambridge introductions to philosophy},
	title = {An introduction to {Gödel}'s theorems},
	isbn = {978-0-521-85784-0},
	language = {eng},
	publisher = {University Press},
	author = {Smith, Peter},
	year = {2007},
	keywords = {Gödel's theorem; Decidability (Mathematical logic)},
}

@incollection{goos_calculating_2002,
	address = {Berlin, Heidelberg},
	title = {Calculating {Functional} {Programs}},
	volume = {2297},
	isbn = {978-3-540-43613-3 978-3-540-47797-6},
	url = {http://link.springer.com/10.1007/3-540-47797-7_5},
	abstract = {Functional programs are merely equations; they may be manipulated by straightforward equational reasoning. In particular, one can use this style of reasoning to calculate programs, in the same way that one calculates numeric values in arithmetic. Many useful theorems for such reasoning derive from an algebraic view of programs, built around datatypes and their operations. Traditional algebraic methods concentrate on initial algebras, constructors, and values; dual co-algebraic methods concentrate on ﬁnal co-algebras, destructors, and processes. Both methods are elegant and powerful; they deserve to be combined.},
	language = {en},
	urldate = {2022-11-07},
	booktitle = {Algebraic and {Coalgebraic} {Methods} in the {Mathematics} of {Program} {Construction}},
	publisher = {Springer Berlin Heidelberg},
	author = {Gibbons, Jeremy},
	editor = {Goos, Gerhard and Hartmanis, Juris and van Leeuwen, Jan and Backhouse, Roland and Crole, Roy and Gibbons, Jeremy},
	year = {2002},
	doi = {10.1007/3-540-47797-7_5},
	note = {Series Title: Lecture Notes in Computer Science},
	pages = {151--203},
}

@misc{staton_lazyppl_nodate,
	title = {{LazyPPL}},
	url = {https://lazyppl.bitbucket.io/index.html},
	abstract = {LazyPPL is a Haskell library for probabilistic programming. It supports lazy use of probability, and we provide new Metropolis-Hastings algorithms to allow this. LazyPPL is inspired by recent ideas in synthetic probability theory and synthetic measure theory such as quasi-Borel spaces and Markov categories. Laziness appears to be a good paradigm for non-parametric statistics. LazyPPL is inspired by many other languages, including Church, Anglican, and MonadBayes.},
	urldate = {2022-11-07},
	author = {Staton, Sam},
}

@article{van_der_rest_completely_2022,
	title = {A completely unique account of enumeration},
	volume = {6},
	issn = {2475-1421},
	abstract = {How can we enumerate the inhabitants of an algebraic datatype? This paper explores a datatype generic solution that works for all regular types and indexed families. The enumerators presented here are provably both complete and unique - they will eventually produce every value exactly once - and fair - they avoid bias when composing enumerators. Finally, these enumerators memoise previously enumerated values whenever possible, thereby avoiding repeatedly recomputing recursive results.},
	language = {eng},
	number = {ICFP},
	journal = {Proceedings of ACM on programming languages},
	author = {van der Rest, C. R. and Swierstra, Wouter},
	year = {2022},
	keywords = {Agda, datatype generic programming, dependently typed programming, interactive proof assistants, property-based testing},
}

@inproceedings{claessen_generating_2014,
	address = {Cham},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Generating {Constrained} {Random} {Data} with {Uniform} {Distribution}},
	volume = {8475},
	isbn = {978-3-319-07150-3},
	doi = {10.1007/978-3-319-07151-0_2},
	abstract = {We present a technique for automatically deriving test data generators from a predicate expressed as a Boolean function. The distribution of these generators is uniform over values of a given size. To make the generation efficient we rely on laziness of the predicate, allowing us to prune the space of values quickly. In contrast, implementing test data generators by hand is labour intensive and error prone. Moreover, handwritten generators often have an unpredictable distribution of values, risking that some values are arbitrarily underrepresented. We also present a variation of the technique where the distribution is skewed in a limited and predictable way, potentially increasing the performance. Experimental evaluation of the techniques shows that the uniform derived generators are much easier to define than hand-written ones, and their performance, while lower, is adequate for some realistic applications.},
	language = {eng},
	publisher = {Springer International Publishing},
	author = {Claessen, Koen and Duregård, Jonas and Pałka, Michał H.},
	year = {2014},
	note = {Book Title: Functional and Logic Programming
ISSN: 0302-9743},
	keywords = {Computer Science, Data Type, Datavetenskap (datalogi), Lambda Term, Memory Consumption, Test Data Generator, Type Checker},
	pages = {18--34},
}

@article{duregard_feat_2012,
	title = {Feat: functional enumeration of algebraic types},
	volume = {47},
	issn = {0362-1340},
	shorttitle = {Feat},
	url = {https://ezproxy-prd.bodleian.ox.ac.uk:2102/10.1145/2430532.2364515},
	doi = {10.1145/2430532.2364515},
	abstract = {In mathematics, an enumeration of a set S is a bijective function from (an initial segment of) the natural numbers to S. We define "functional enumerations" as efficiently computable such bijections. This paper describes a theory of functional enumeration and provides an algebra of enumerations closed under sums, products, guarded recursion and bijections. We partition each enumerated set into numbered, finite subsets. We provide a generic enumeration such that the number of each part corresponds to the size of its values (measured in the number of constructors). We implement our ideas in a Haskell library called testing-feat, and make the source code freely available. Feat provides efficient "random access" to enumerated values. The primary application is property-based testing, where it is used to define both random sampling (for example QuickCheck generators) and exhaustive enumeration (in the style of SmallCheck). We claim that functional enumeration is the best option for automatically generating test cases from large groups of mutually recursive syntax tree types. As a case study we use Feat to test the pretty-printer of the Template Haskell library (uncovering several bugs).},
	number = {12},
	urldate = {2022-11-07},
	journal = {ACM SIGPLAN Notices},
	author = {Duregård, Jonas and Jansson, Patrik and Wang, Meng},
	month = sep,
	year = {2012},
	keywords = {enumeration, memoisation, property-based testing},
	pages = {61--72},
}

@article{anonymous_introduction_1998,
	title = {Introduction to {Matrix} {Analysis}, {Second} {Edition}},
	volume = {105},
	copyright = {Copyright Mathematical Association Of America Feb 1998},
	issn = {00029890},
	url = {https://www.proquest.com/docview/203724843/citation/875CBE2423A34282PQ/1},
	language = {English},
	number = {2},
	urldate = {2022-11-07},
	journal = {The American Mathematical Monthly},
	author = {Anonymous},
	month = feb,
	year = {1998},
	note = {Num Pages: 1
Place: Washington, United Kingdom
Publisher: Taylor \& Francis Ltd.},
	keywords = {Mathematics},
	pages = {195},
}

@book{noauthor_algebraic_nodate,
	title = {Algebraic and {Coalgebraic} {Methods} in the {Mathematics} of {Program} {Construction}},
	url = {https://ezproxy-prd.bodleian.ox.ac.uk:2120/book/10.1007/3-540-47797-7},
	language = {en},
	urldate = {2022-11-07},
}

@misc{leinster_basic_2016,
	title = {Basic {Category} {Theory}},
	url = {http://arxiv.org/abs/1612.09375},
	doi = {10.48550/arXiv.1612.09375},
	abstract = {This short introduction to category theory is for readers with relatively little mathematical background. At its heart is the concept of a universal property, important throughout mathematics. After a chapter introducing the basic definitions, separate chapters present three ways of expressing universal properties: via adjoint functors, representable functors, and limits. A final chapter ties the three together. For each new categorical concept, a generous supply of examples is provided, taken from different parts of mathematics. At points where the leap in abstraction is particularly great (such as the Yoneda lemma), the reader will find careful and extensive explanations.},
	urldate = {2022-11-07},
	publisher = {arXiv},
	author = {Leinster, Tom},
	month = dec,
	year = {2016},
	note = {arXiv:1612.09375 [math]},
	keywords = {Mathematics - Algebraic Topology, Mathematics - Category Theory, Mathematics - Logic},
}

@article{wrenn_using_2020,
	title = {Using {Relational} {Problems} to {Teach} {Property}-{Based} {Testing}},
	volume = {5},
	issn = {2473-7321},
	url = {http://arxiv.org/abs/2010.16305},
	doi = {10.22152/programming-journal.org/2021/5/9},
	abstract = {Context: The success of QuickCheck has led to the development of property-based testing (PBT) libraries for many languages and the process is getting increasing attention. However, unlike regular testing, PBT is not widespread in collegiate curricula. Furthermore, the value of PBT is not limited to software testing. The growing use of formal methods in, and the growth of software synthesis, all create demand for techniques to train students and developers in the art of specification writing. We posit that PBT forms a strong bridge between testing and the act of specification: it's a form of testing where the tester is actually writing abstract specifications. Inquiry: Even well-informed technologists mention the difficulty of finding good motivating examples for its use. We take steps to fill this lacuna. Approach \& Knowledge: We find that the use of "relational" problems -- those for which an input may admit multiple valid outputs -- easily motivates the use of PBT. We also notice that such problems are readily available in the computer science pantheon of problems (e.g., many graph and sorting algorithms). We have been using these for some years now to teach PBT in collegiate courses. Grounding: In this paper, we describe the problems we use and report on students? completion of them. We believe the problems overcome some of the motivation issues described above. We also show that students can do quite well at PBT for these problems, suggesting that the topic is well within their reach. In the process, we introduce a simple method to evaluate the accuracy of their specifications, and use it to characterize their common mistakes. Importance: Based on our findings, we believe that relational problems are an underutilized motivating example for PBT. We hope this paper initiates a catalog of such problems for educators (and developers) to use, and also provides a concrete (though by no means exclusive) method to analyze the quality of PBT.},
	number = {2},
	urldate = {2022-11-07},
	journal = {The Art, Science, and Engineering of Programming},
	author = {Wrenn, John and Nelson, Tim and Krishnamurthi, Shriram},
	month = oct,
	year = {2020},
	note = {arXiv:2010.16305 [cs]},
	keywords = {Computer Science - Software Engineering},
	pages = {9},
}

@article{nelson_automated_2021,
	title = {Automated, {Targeted} {Testing} of {Property}-{Based} {Testing} {Predicates}},
	volume = {6},
	issn = {2473-7321},
	url = {http://arxiv.org/abs/2111.10414},
	doi = {10.22152/programming-journal.org/2022/6/10},
	abstract = {Context: This work is based on property-based testing (PBT). PBT is an increasingly important form of software testing. Furthermore, it serves as a concrete gateway into the abstract area of formal methods. Specifically, we focus on students learning PBT methods. Inquiry: How well do students do at PBT? Our goal is to assess the quality of the predicates they write as part of PBT. Prior work introduced the idea of decomposing the predicate's property into a conjunction of independent subproperties. Testing the predicate against each subproperty gives a "semantic" understanding of their performance. Approach: The notion of independence of subproperties both seems intuitive and was an important condition in prior work. First, we show that this condition is overly restrictive and might hide valuable information: it both undercounts errors and makes it hard to capture misconceptions. Second, we introduce two forms of automation, one based on PBT tools and the other on SAT-solving, to enable testing of student predicates. Third, we compare the output of these automated tools against manually-constructed tests. Fourth, we also measure the performance of those tools. Finally, we re-assess student performance reported in prior work. Knowledge: We show the difficulty caused by the independent subproperty requirement. We provide insight into how to use automation effectively to assess PBT predicates. In particular, we discuss the steps we had to take to beat human performance. We also provide insight into how to make the automation work efficiently. Finally, we present a much richer account than prior work of how students did. Grounding: Our methods are grounded in mathematical logic. We also make use of well-understood principles of test generation from more formal specifications. This combination ensures the soundness of our work. We use standard methods to measure performance. Importance: As both educators and programmers, we believe PBT is a valuable tool for students to learn, and its importance will only grow as more developers appreciate its value. Effective teaching requires a clear understanding of student knowledge and progress. Our methods enable a rich and automated analysis of student performance on PBT that yields insight into their understanding and can capture misconceptions. We therefore expect these results to be valuable to educators.},
	number = {2},
	urldate = {2022-11-07},
	journal = {The Art, Science, and Engineering of Programming},
	author = {Nelson, Tim and Rivera, Elijah and Soucie, Sam and Del Vecchio, Thomas and Wrenn, John and Krishnamurthi, Shriram},
	month = nov,
	year = {2021},
	note = {arXiv:2111.10414 [cs]},
	keywords = {Computer Science - Programming Languages},
	pages = {10},
}

@misc{van_de_meent_introduction_2021,
	title = {An {Introduction} to {Probabilistic} {Programming}},
	url = {http://arxiv.org/abs/1809.10756},
	doi = {10.48550/arXiv.1809.10756},
	abstract = {This book is a graduate-level introduction to probabilistic programming. It not only provides a thorough background for anyone wishing to use a probabilistic programming system, but also introduces the techniques needed to design and build these systems. It is aimed at people who have an undergraduate-level understanding of either or, ideally, both probabilistic machine learning and programming languages. We start with a discussion of model-based reasoning and explain why conditioning is a foundational computation central to the fields of probabilistic machine learning and artificial intelligence. We then introduce a first-order probabilistic programming language (PPL) whose programs correspond to graphical models with a known, finite, set of random variables. In the context of this PPL we introduce fundamental inference algorithms and describe how they can be implemented. We then turn to higher-order probabilistic programming languages. Programs in such languages can define models with dynamic computation graphs, which may not instantiate the same set of random variables in each execution. Inference requires methods that generate samples by repeatedly evaluating the program. Foundational algorithms for this kind of language are discussed in the context of an interface between program executions and an inference controller. Finally we consider the intersection of probabilistic and differentiable programming. We begin with a discussion of automatic differentiation, and how it can be used to implement efficient inference methods based on Hamiltonian Monte Carlo. We then discuss gradient-based maximum likelihood estimation in programs that are parameterized using neural networks, how to amortize inference using by learning neural approximations to the program posterior, and how language features impact the design of deep probabilistic programming systems.},
	urldate = {2022-11-07},
	publisher = {arXiv},
	author = {van de Meent, Jan-Willem and Paige, Brooks and Yang, Hongseok and Wood, Frank},
	month = oct,
	year = {2021},
	note = {arXiv:1809.10756 [cs, stat]},
	keywords = {Computer Science - Artificial Intelligence, Computer Science - Machine Learning, Computer Science - Programming Languages, Statistics - Machine Learning},
}

@inproceedings{loscher_targeted_2017,
	address = {New York, NY, USA},
	series = {{ISSTA} 2017},
	title = {Targeted property-based testing},
	isbn = {978-1-4503-5076-1},
	url = {https://ezproxy-prd.bodleian.ox.ac.uk:2102/10.1145/3092703.3092711},
	doi = {10.1145/3092703.3092711},
	abstract = {We introduce targeted property-based testing, an enhanced form of property-based testing that aims to make the input generation component of a property-based testing tool guided by a search strategy rather than being completely random. Thus, this testing technique combines the advantages of both search-based and property-based testing. We demonstrate the technique with the framework we have built, called Target, and show its effectiveness on three case studies. The first of them demonstrates how Target can employ simulated annealing to generate sensor network topologies that form configurations with high energy consumption. The second case study shows how the generation of routing trees for a wireless network equipped with directional antennas can be guided to fulfill different energy metrics. The third case study employs Target to test the noninterference property of information-flow control abstract machine designs, and compares it with a sophisticated hand-written generator for programs of these abstract machines.},
	urldate = {2022-11-07},
	booktitle = {Proceedings of the 26th {ACM} {SIGSOFT} {International} {Symposium} on {Software} {Testing} and {Analysis}},
	publisher = {Association for Computing Machinery},
	author = {Löscher, Andreas and Sagonas, Konstantinos},
	month = jul,
	year = {2017},
	keywords = {PropEr, Property-based testing, QuickCheck, Search-based testing},
	pages = {46--56},
}

@misc{taylor_twenty_2018,
	type = {Career {Column}},
	title = {Twenty things {I} wish {I}’d known when {I} started my {PhD}},
	copyright = {2021 Nature},
	url = {https://ezproxy-prd.bodleian.ox.ac.uk:2268/articles/d41586-018-07332-x},
	abstract = {Recent PhD graduate Lucy A. Taylor shares the advice she and her colleagues wish they had received.},
	language = {En},
	urldate = {2022-11-07},
	journal = {Nature},
	author = {Taylor, Lucy A.},
	month = nov,
	year = {2018},
	doi = {10.1038/d41586-018-07332-x},
	note = {Bandiera\_abtest: a
Cg\_type: Career Column
Publisher: Nature Publishing Group
Subject\_term: Careers, Lab life, Education},
}

@inproceedings{runciman_smallcheck_2008,
	series = {Haskell '08},
	title = {Smallcheck and lazy smallcheck: automatic exhaustive testing for small values},
	isbn = {978-1-60558-064-7},
	shorttitle = {Smallcheck and lazy smallcheck},
	doi = {10.1145/1411286.1411292},
	abstract = {This paper describes two Haskell libraries for property-based testing. Following the lead of QuickCheck, these testing libraries SmallCheck and Lazy SmallCheck also use type-based generators to obtain test-sets of finite values for which properties are checked, and report any counter-examples found. But instead of using a sample of randomly generated values they test properties for all values up to some limiting depth, progressively increasing this limit. The paper explains the design and implementation of both libraries and evaluates them in comparison with each other and with QuickCheck.},
	language = {eng},
	publisher = {ACM},
	author = {Runciman, Colin and Naylor, Matthew and Lindblad, Fredrik},
	year = {2008},
	note = {Book Title: Proceedings of the first ACM SIGPLAN symposium on haskell},
	keywords = {embedded language, exhaustive search, lazy evaluation, property-based testing, type classes},
	pages = {37--48},
}

@misc{blass_seven_2019,
	title = {Seven {Trees} in {One}},
	url = {http://arxiv.org/abs/math/9405205},
	doi = {10.48550/arXiv.math/9405205},
	abstract = {Following a remark of Lawvere, we explicitly exhibit a particularly elementary bijection between the set T of finite binary trees and the set T{\textasciicircum}7 of seven-tuples of such trees. "Particularly elementary" means that the application of the bijection to a seven-tuple of trees involves case distinctions only down to a fixed depth (namely four) in the given seven-tuple. We clarify how this and similar bijections are related to the free commutative semiring on one generator X subject to X=1+X{\textasciicircum}2. Finally, our main theorem is that the existence of particularly elementary bijections can be deduced from the provable existence, in intuitionistic type theory, of any bijections at all.},
	urldate = {2022-11-07},
	publisher = {arXiv},
	author = {Blass, Andreas},
	month = aug,
	year = {2019},
	note = {arXiv:math/9405205
version: 2},
	keywords = {Mathematics - Logic},
}
