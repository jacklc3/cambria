-- Polymorphic swap with abstract references
--
-- swap is polymorphic: forall a. (a, a) -> (a, a)!S
-- We use it at both (Int, Int) and ($p, $p).
--
-- When instantiated at $p, swap operates on abstract reference
-- identifiers — values whose concrete type (Unique) is hidden
-- by the handler. The polymorphic function treats them as opaque
-- values it can shuffle around without inspecting.

with handler {
  $p -> Unique,
  return x  -> return (fun _ -> return x),
  get a k -> return (fun s -> k (lookup (a, s)) s),
  set x k -> return (fun s -> k () (insert (x, s))),
  ref x k -> do a <- !unique () in return (fun s ->
    k a (insert ((a, x), s))),
  finally s -> s empty
} handle (
  declare !get : $p ~> Int.
  declare !set : $p & Int ~> Unit.
  declare !ref : Int ~> $p.

  -- Polymorphic swap: forall a. (a, a) -> (a, a)
  do swap <- return (fun (x, y) -> return (y, x)) in

  -- Use at (Int, Int)
  do swapped_ints <- swap (10, 20) in

  -- Use at ($p, $p) — swapping abstract reference identifiers!
  do a <- !ref 100 in
  do b <- !ref 200 in
  do (r1, r2) <- swap (a, b) in

  return (swapped_ints, (!get r1, !get r2))
)
